import argparse
import codecs
import re
import socket
import sys
from builtins import str
from copy import copy
from struct import unpack

import dns.name
import dns.resolver
from impacket.structure import Structure
from ldap3 import NTLM, Server, Connection, ALL, LEVEL

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes


class DNS_RPC_RECORD_AAAA(Structure):
    """
    DNS_RPC_RECORD_AAAA
    [MS-DNSP] section 2.2.2.2.4.17
    """
    structure = (
        ('ipv6Address', '16s'),
    )

    def formatCanonical(self):
        return socket.inet_ntop(socket.AF_INET6, self['ipv6Address'])


class DNS_COUNT_NAME(Structure):
    """
    DNS_COUNT_NAME
    Used for FQDNs in LDAP communication
    MUST be converted to DNS_RPC_NAME for RPC communication
    [MS-DNSP] section 2.2.2.2.2
    """
    structure = (
        ('Length', 'B-RawName'),
        ('LabelCount', 'B'),
        ('RawName', ':')
    )

    def toFqdn(self):
        ind = 0
        labels = []
        for i in range(self['LabelCount']):
            nextlen = unpack('B', self['RawName'][ind:ind+1])[0]
            labels.append(self['RawName'][ind+1:ind+1+nextlen].decode('utf-8'))
            ind += nextlen + 1
        # For the final dot
        labels.append('')
        return '.'.join(labels)


class DNS_RPC_RECORD_A(Structure):
    """
    DNS_RPC_RECORD_A
    [MS-DNSP] section 2.2.2.2.4.1
    """
    structure = (
        ('address', ':'),
    )

    def formatCanonical(self):
        return socket.inet_ntoa(self['address'])

    def fromCanonical(self, canonical):
        self['address'] = socket.inet_aton(canonical)


class DNS_RPC_RECORD_NODE_NAME(Structure):
    """
    DNS_RPC_RECORD_NODE_NAME
    [MS-DNSP] section 2.2.2.2.4.2
    """
    structure = (
        ('nameNode', ':', DNS_COUNT_NAME),
    )

class DNS_RPC_RECORD_SOA(Structure):
    """
    DNS_RPC_RECORD_SOA
    [MS-DNSP] section 2.2.2.2.4.3
    """
    structure = (
        ('dwSerialNo', '>L'),
        ('dwRefresh', '>L'),
        ('dwRetry', '>L'),
        ('dwExpire', '>L'),
        ('dwMinimumTtl', '>L'),
        ('namePrimaryServer', ':', DNS_COUNT_NAME),
        ('zoneAdminEmail', ':', DNS_COUNT_NAME)
    )


class DNS_RECORD(Structure):
    """
    dnsRecord - used in LDAP
    [MS-DNSP] section 2.3.2.2
    """
    structure = (
        ('DataLength', '<H-Data'),
        ('Type', '<H'),
        ('Version', 'B=5'),
        ('Rank', 'B'),
        ('Flags', '<H=0'),
        ('Serial', '<L'),
        ('TtlSeconds', '>L'),
        ('Reserved', '<L=0'),
        ('TimeStamp', '<L=0'),
        ('Data', ':')
    )


# From: https://docs.microsoft.com/en-us/windows/win32/dns/dns-constants
RECORD_TYPE_MAPPING = {
    0: 'ZERO',
    1: 'A',
    2: 'NS',
    5: 'CNAME',
    6: 'SOA',
    12: 'PTR',
    #15: 'MX',
    #16: 'TXT',
    28: 'AAAA',
    33: 'SRV'
}


class PluginADAdiDNSDump(PluginAdExploitBase):
    """
    AdiDNSDump信息探测
    """

    display = "AdiDNSDump信息探测"
    alias = "adi_dns_dmp"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = "AdiDNSDump信息探测"
        parser.add_argument("-d", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("--username", help="username", required=True, dest="username")
        parser.add_argument("--password", help="password", required=True, dest="password")
        parser.add_argument("--dc-ip", help="domain ip address", required=True, dest="dc_ip")
        parser.add_argument("--ssl", action='store_true', help="Connect to LDAP server using SSL")

    def run_script(self, args) -> dict:
        domain_fqdn = args.domain
        dc_ip = args.dc_ip
        username = f"{domain_fqdn}\\{args.username}"
        password = args.password
        required_ssl = args.ssl
        result = copy(self.result)

        authentication = NTLM

        # define the server and the connection
        s = Server(dc_ip, get_info=ALL)
        if required_ssl:
            s = Server(dc_ip, get_info=ALL, port=636, use_ssl=True)
        output.debug('Connecting to host...')
        c = Connection(s, user=username, password=password, authentication=authentication, auto_referrals=False)
        output.debug('Binding to host')
        # perform the Bind operation
        if not c.bind():
            output.info('Could not bind with specified credentials')
            output.debug(c.result)
            sys.exit(1)
        domainroot = s.info.other['defaultNamingContext'][0]
        forestroot = s.info.other['rootDomainNamingContext'][0]
        dnsroot = 'CN=MicrosoftDNS,DC=DomainDnsZones,%s' % domainroot

        # Default to current domain
        zone = ldap2domain(domainroot)

        searchtarget = 'DC=%s,%s' % (zone, dnsroot)
        sfilter = "(objectClass=*)"
        c.extend.standard.paged_search(searchtarget, sfilter, search_scope=LEVEL,
                                       attributes=['dnsRecord', 'dNSTombstoned', 'name'], paged_size=500,
                                       generator=False)
        dnsresolver = get_dns_resolver(dc_ip)
        outdata = []
        for targetentry in c.response:
            if targetentry['type'] != 'searchResEntry':
                # print(targetentry)
                continue
            if not targetentry['attributes']['name']:
                # No permission to view those records
                recordname = targetentry['dn'][3:targetentry['dn'].index(searchtarget) - 1]
                # if not args.resolve:
                #     outdata.append({'name': recordname, 'type': '?', 'value': '?'})
                #     if args.verbose:
                #         output.debug('Found hidden record %s' % recordname)
                # else:
                    # Resolve A query
                try:
                    res = dnsresolver.query('%s.%s.' % (recordname, zone), 'A', False,
                                            raise_on_no_answer=False)
                except (
                        dns.resolver.NoAnswer, dns.resolver.NXDOMAIN, dns.resolver.Timeout,
                        dns.name.EmptyLabel) as e:
                    output.debug('Could not resolve node %s (probably no A record assigned to name)' % recordname)
                    outdata.append({'name': recordname, 'type': '?', 'value': '?'})
                    continue
                if len(res.response.answer) == 0:
                    output.debug('Could not resolve node %s (probably no A record assigned to name)' % recordname)
                    outdata.append({'name': recordname, 'type': '?', 'value': '?'})
                    continue
                for answer in res.response.answer:
                    try:
                        outdata.append({'name': recordname, 'type': RECORD_TYPE_MAPPING[answer.rdtype],
                                        'value': str(answer[0])})
                    except KeyError:
                        output.error('Unexpected record type seen: {}'.format(answer.rdtype))
            else:
                recordname = targetentry['attributes']['name']
                output.debug('Found record %s' % targetentry['attributes']['name'])

            # Skip tombstoned records unless requested
            if targetentry['attributes']['dNSTombstoned'] and not args.include_tombstoned:
                continue

            for record in targetentry['raw_attributes']['dnsRecord']:
                dr = DNS_RECORD(record)

                if dr['Type'] == 1:
                    address = DNS_RPC_RECORD_A(dr['Data'])
                    outdata.append({'name': recordname, 'type': RECORD_TYPE_MAPPING[dr['Type']],
                                    'value': address.formatCanonical()})
                if dr['Type'] in [a for a in RECORD_TYPE_MAPPING if RECORD_TYPE_MAPPING[a] in ['CNAME', 'NS', 'PTR']]:
                    address = DNS_RPC_RECORD_NODE_NAME(dr['Data'])
                    outdata.append({'name': recordname, 'type': RECORD_TYPE_MAPPING[dr['Type']],
                                    'value': address[list(address.fields)[0]].toFqdn()})
                elif dr['Type'] == 28:
                    address = DNS_RPC_RECORD_AAAA(dr['Data'])
                    outdata.append({'name': recordname, 'type': RECORD_TYPE_MAPPING[dr['Type']],
                                    'value': address.formatCanonical()})
                elif dr['Type'] not in [a for a in RECORD_TYPE_MAPPING if
                                        RECORD_TYPE_MAPPING[a] in ['A', 'AAAA,' 'CNAME', 'NS']]:
                    output.debug('Unexpected record type seen: {}'.format(dr['Type']))

                continue
        if len(outdata) > 0:
            output.info('Found %d records' % len(outdata))
            r = []
            for row in outdata:
                r.append({
                    "name":row["name"],
                    "type":row["type"],
                    "value":row["value"]
                })

            result["status"] = 1
            result["data"]["instance_list"] = r
        return result


def ldap2domain(ldap):
    return re.sub(',DC=', '.', ldap[ldap.find('DC='):], flags=re.I)[3:]


def get_dns_resolver(server):
    # Create a resolver object
    dnsresolver = dns.resolver.Resolver()
    # Is our host an IP? In that case make sure the server IP is used
    # if not assume lookups are working already
    try:
        if server.startswith('ldap://'):
            server = server[7:]
        if server.startswith('ldaps://'):
            server = server[8:]
        socket.inet_aton(server)
        dnsresolver.nameservers = [server]
    except socket.error:
        output.error('Using System DNS to resolve unknown entries. Make sure resolving your target domain works here or specify an IP'\
                ' as target host to use that server for queries')
    return dnsresolver