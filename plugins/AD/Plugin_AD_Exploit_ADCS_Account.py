import argparse
import random
import string
from copy import copy

import ldap3

from modules.certipylib.formatting import pretty_print
from modules.certipylib.ldap import LDAPConnection
from modules.certipylib.target import Target
from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes


class PluginADADCSAccount(PluginAdExploitBase):
    display = "certipy account 脚本"
    alias = "adcs_account"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("--action", choices=["create", "read", "update", "delete"], help="Action", required=True,
                            dest="action")

        group = parser.add_argument_group("authentication options")
        group.add_argument("-d", "--domain", metavar="test.lab", help="domain name. Format: test.lab", required=True, dest="domain")
        group.add_argument("-u", "-username", metavar="username", dest="username", action="store",
                           help="Username. Format: username", )
        group.add_argument("-p", "-password", metavar="password", dest="password", action="store", help="Password", )
        group.add_argument("--hashes", action="store", metavar="[LMHASH:]NTHASH",
                           help="NTLM hash, format is [LMHASH:]NTHASH", )
        group.add_argument("-k", action="store_true", dest="do_kerberos",
                           help="Use Kerberos authentication. Grabs credentials from ccache file "
                                "(KRB5CCNAME) based on target parameters. If valid credentials cannot be found, it will use the "
                                "ones specified in the command line", )
        group.add_argument("--sspi", dest="use_sspi", action="store_true",
                           help="Use Windows Integrated Authentication (SSPI)", )
        group.add_argument("--aes", action="store", metavar="hex key",
                           help="AES key to use for Kerberos Authentication " "(128 or 256 bits)", )
        group.add_argument("--no-pass", action="store_true", help="Don't ask for password (useful for -k and -sspi)", )

        group = parser.add_argument_group("target")
        group.add_argument("--user", action="store", metavar="SAM Account Name",
                           help="Logon name for the account to target", required=True, )
        group.add_argument("--group", action="store", metavar="CN=Computers,DC=test,DC=local",
                           help="Group to which the account will be added."
                                "If omitted, CN=Computers,<default path> will be used,", )

        group = parser.add_argument_group("attribute options")
        group.add_argument("--dns", action="store", metavar="Set the DNS host name for the account", )
        group.add_argument("--upn", action="store", metavar="Set the UPN for the account", )
        group.add_argument("--sam", action="store", metavar="Set the SAM Account Name for the account", )
        group.add_argument("--spns", action="store", metavar="Set the SPNS for the account (comma-separated)", )
        group.add_argument("--pass", action="store", dest="passw", metavar="Set the password for the account", )

        group = parser.add_argument_group("connection options")
        group.add_argument("--scheme", action="store", metavar="ldap scheme", choices=["ldap", "ldaps"],
                           default="ldaps", )
        group.add_argument("--dc-ip", action="store", metavar="ip address",
                           help="IP Address of the domain controller. If omitted it will use the domain part (FQDN) specified in "
                                "the target parameter", )
        group.add_argument("--adcs-ip", action="store", metavar="ip address",
                           help="IP Address of the target machine. If omitted it will use whatever was specified as target. "
                                "This is useful when target is the NetBIOS name and you cannot resolve it", )
        # group.add_argument("--target", action="store", metavar="dns/ip address",
        #                    help="DNS Name or IP Address of the target machine. Required for Kerberos or SSPI authentication", )
        group.add_argument("--ns", action="store", metavar="nameserver", help="Nameserver for DNS resolution", )
        group.add_argument("--dns-tcp", action="store_true", help="Use TCP instead of UDP for DNS queries")
        group.add_argument("--timeout", action="store", metavar="seconds", help="Timeout for connections", default=5,
                           type=int, )

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        setattr(args, "target_ip", args.adcs_ip)
        setattr(args, "target", None)

        _domain_name = ".".join(args.domain.split(".")[-2::])
        args.username = f"{args.username}@{_domain_name}"

        target = Target.from_options(args, dc_as_target=True)
        del args.target

        account = Account(target, **vars(args))

        actions = {
            "create": account.create,
            "read": account.read,
            "update": account.update,
            "delete": account.delete,
        }

        actions[args.action]()

        return result


class Account:
    def __init__(
        self,
        target: Target,
        user: str,
        dns: str = None,
        upn: str = None,
        sam: str = None,
        spns: str = None,
        passw: str = None,
        group: str = None,
        scheme: str = "ldaps",
        connection: LDAPConnection = None,
        timeout: int = 5,
        debug: bool = False,
        **kwargs
    ):
        self.target = target
        self.user = user
        self.dns = dns
        self.upn = upn
        self.sam = sam
        self.spns = spns
        self.password = passw
        self.group = group
        self.scheme = scheme
        self._connection = connection
        self.timeout = timeout
        self.verbose = debug
        self.kwargs = kwargs

    @property
    def connection(self) -> LDAPConnection:
        if self._connection is not None:
            return self._connection

        self._connection = LDAPConnection(self.target, self.scheme)
        self._connection.connect()

        return self._connection

    def create(self):
        username = self.user
        if self.sam is not None:
            output.error(
                "The parameter -sam overrides the -user parameter for the create operation"
            )
            res = input("Do you want to continue? (Y/n) ").rstrip("\n")
            if res.lower() == "n":
                return False

            username = self.sam

        user = self.connection.get_user(username, silent=True)
        if user is not None:
            output.error(
                "User %s already exists. If you want to update the user, specify the 'update' action"
                % repr(user.get("sAMAccountName"))
            )
            return False

        group = self.group
        if group is None:
            group = "CN=Computers," + self.connection.default_path

        if username[-1] != "$":
            username += "$"

        password = self.password
        if password is None:
            password = "".join(
                random.choice(string.ascii_letters + string.digits) for _ in range(16)
            )
            self.password = password

        dns = self.dns
        if dns is None:
            dns = (username.rstrip("$") + "." + self.connection.domain).lower()

        hostname = username[:-1]
        dn = "CN=%s,%s" % (hostname, group)

        spns = self.spns
        if spns is None:
            spns = [
                "HOST/%s" % username.rstrip("$"),
                "RestrictedKrbHost/%s" % username.rstrip("$"),
            ]
        else:
            spns = list(
                filter(
                    lambda x: len(x) > 0, map(lambda x: x.strip(), self.spns.split(","))
                )
            )

        attributes = {
            "sAMAccountName": username,
            "unicodePwd": password,  # just for the pretty print
            "userAccountControl": 0x1000,
            "servicePrincipalName": spns,
            "dnsHostName": dns,
        }

        output.info("Creating new account:")
        pretty_print(attributes, indent=2)

        attributes["unicodePwd"] = ('"%s"' % password).encode("utf-16-le")

        result = self.connection.add(
            dn,
            ["top", "person", "organizationalPerson", "user", "computer"],
            attributes,
        )

        if result["result"] == 0:
            output.info(
                "Successfully created account %s with password %s"
                % (repr(username), repr(password))
            )
            return True
        elif result["result"] == ldap3.core.results.RESULT_INSUFFICIENT_ACCESS_RIGHTS:
            output.error(
                "User %s doesn't have the right to create a machine account"
                % repr(self.target.username)
            )
        elif (
            result["result"] == ldap3.core.results.RESULT_UNWILLING_TO_PERFORM
            and int(result["message"].split(":")[0].strip(), 16) == 0x216D
        ):
            output.error(
                "Machine account quota exceeded for %s" % repr(self.target.username)
            )
        else:
            output.error(
                "Received unknown error: (%s) %s"
                % (result["description"], result["message"])
            )

        return False

    def read(self):
        user = self.connection.get_user(self.user)
        if user is None:
            return False

        attribute_values = {}
        attributes = [
            "cn",
            "distinguishedName",
            "name",
            "objectSid",
            "sAMAccountName",
            "dNSHostName",
            "servicePrincipalName",
        ]

        output.info("Reading attributes for %s:" % repr(user.get("sAMAccountName")))
        for attribute in attributes:
            value = user.get(attribute)
            if value is not None:
                attribute_values[attribute] = value
        pretty_print(attribute_values, indent=2)

    def update(self):
        user = self.connection.get_user(self.user)
        if user is None:
            return False

        changes = {}
        changes_formatted = {}

        attribute_mapping = {
            "unicodePwd": self.password,
            "dNSHostName": self.dns,
            "userPrincipalName": self.upn,
            "sAMAccountName": self.sam,
            "servicePrincipalName": list(
                filter(
                    lambda x: len(x) > 0, map(lambda x: x.strip(), self.spns.split(","))
                )
            )
            if self.spns is not None
            else None,
        }

        for attribute, value in attribute_mapping.items():
            if value is None:
                continue

            if value == "" or len(value) == 0:
                changes[attribute] = [
                    (
                        ldap3.MODIFY_DELETE,
                        [],
                    )
                ]
                changes_formatted[attribute] = "*DELETED*"
            else:
                if attribute == "unicodePwd":
                    encoded_value = ('"%s"' % value).encode("utf-16-le")
                    changes_formatted[attribute] = [value]
                else:
                    if isinstance(value, list):
                        encoded_value = value
                    else:
                        encoded_value = [value.encode("utf-8")]
                    changes_formatted[attribute] = value

                changes[attribute] = [
                    (
                        ldap3.MODIFY_REPLACE,
                        encoded_value,
                    )
                ]

        output.info("Updating user %s:" % repr(user.get("sAMAccountName")))
        pretty_print(changes_formatted, indent=2)

        result = self.connection.modify(
            user.get("distinguishedName"),
            changes,
        )

        if result["result"] == 0:
            output.info("Successfully updated %s" % repr(user.get("sAMAccountName")))
            return True
        elif result["result"] == ldap3.core.results.RESULT_INSUFFICIENT_ACCESS_RIGHTS:
            output.error(
                "User %s doesn't have permission to update these attributes on %s"
                % (repr(self.target.username), repr(user.get("sAMAccountName")))
            )
        else:
            output.error("Received error: %s" % result["message"])

        return False

    def delete(self):
        user = self.connection.get_user(self.user)
        if user is None:
            return False

        result = self.connection.delete(user.get("distinguishedName"))
        if result["result"] == 0:
            output.info("Successfully deleted %s" % repr(user.get("sAMAccountName")))
            return True
        elif result["result"] == ldap3.core.results.RESULT_INSUFFICIENT_ACCESS_RIGHTS:
            output.error(
                "User %s doesn't have permission to delete %s"
                % (repr(self.target.username), repr(user.get("sAMAccountName")))
            )
        else:
            output.error("Received error: %s" % result["message"])
