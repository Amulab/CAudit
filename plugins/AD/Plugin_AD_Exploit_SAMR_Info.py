import argparse
from copy import copy
from datetime import datetime

from impacket.dcerpc.v5 import dtypes
from impacket.dcerpc.v5 import transport, samr
from impacket.dcerpc.v5.rpcrt import DCERPCException
from impacket.nt_errors import STATUS_MORE_ENTRIES

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes
from utils.excep import ListUsersException


class PluginADSAMRInformation(PluginAdExploitBase):
    """
    SAMR信息探测
    """

    display = "SAMR信息探测"
    alias = "samr_info"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-D", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("--username", help="username", required=True, dest="username")
        parser.add_argument("--password", help="password", required=True, dest="password")
        parser.add_argument("--dc-ip", help="domain ip address", required=False, dest="dc_ip")
        parser.add_argument('--hash', help='NTLM hashes, format is LMHASH:NTHASH', required=False,
                            action="store", metavar="LMHASH:NTHASH", dest="hash")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        domain, username, password, remoteName = args.domain, args.username, args.password, args.dc_ip

        if domain is None:
            domain = ''

        dumper = SAMRDump(username, password, domain, args.hash)
        dumper.dump(remoteName, remoteName, username, None)

        return result


class SAMRDump:
    def __init__(self, username='', password='', domain='', hashes=None,
                 aesKey=None, doKerberos=False, kdcHost=None, port=445, csvOutput=False):

        self.__username = username
        self.__password = password
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__aesKey = aesKey
        self.__doKerberos = doKerberos
        self.__kdcHost = kdcHost
        self.__port = port
        self.__csvOutput = csvOutput

        if hashes is not None:
            self.__lmhash, self.__nthash = hashes.split(':')

    @staticmethod
    def getUnixTime(t):
        t -= 116444736000000000
        t /= 10000000
        return t

    def dump(self, remoteName, remoteHost, username=None, groupname=None):
        """Dumps the list of users and shares registered present at
        remoteName. remoteName is a valid host name or IP address.
        """

        entries = []

        output.info('Retrieving endpoint list from %s' % remoteName)

        stringbinding = r'ncacn_np:%s[\pipe\samr]' % remoteName
        output.debug('StringBinding %s' % stringbinding)
        rpctransport = transport.DCERPCTransportFactory(stringbinding)
        rpctransport.set_dport(self.__port)
        rpctransport.setRemoteHost(remoteHost)

        if hasattr(rpctransport, 'set_credentials'):
            # This method exists only for selected protocol sequences.
            rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash,
                                         self.__nthash, self.__aesKey)
        rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)

        try:
            entries = self.__fetchList(rpctransport, username, groupname)
        except Exception as e:
            output.critical(str(e))

        # Display results.

        if self.__csvOutput is True:
            output.info(
                '#Name,RID,FullName,PrimaryGroupId,BadPasswordCount,LogonCount,PasswordLastSet,PasswordDoesNotExpire,AccountIsDisabled,UserComment,ScriptPath')

        for entry in entries:
            (username, uid, user, rids, ridname) = entry
            pwdLastSet = (user['PasswordLastSet']['HighPart'] << 32) + user['PasswordLastSet']['LowPart']
            PasswordCanChange = (user['PasswordCanChange']['HighPart'] << 32) + user['PasswordCanChange']['LowPart']
            PasswordMustChange = (user['PasswordMustChange']['HighPart'] << 32) + user['PasswordMustChange']['LowPart']
            LastLogon = (user['LastLogon']['HighPart'] << 32) + user['LastLogon']['LowPart']

            if pwdLastSet == 0:
                pwdLastSet = '<never>'
            else:
                pwdLastSet = str(datetime.fromtimestamp(self.getUnixTime(pwdLastSet)))
            if PasswordCanChange == 0:
                pwCanChange = "<never>"
            else:
                pwCanChange = str(datetime.fromtimestamp(self.getUnixTime(PasswordCanChange)))

            if LastLogon == 0:
                UserLastLogon = '<never>'
            else:
                UserLastLogon = str(datetime.fromtimestamp(self.getUnixTime(LastLogon)))
            try:
                pwdMustChange = str(datetime.fromtimestamp(self.getUnixTime(PasswordMustChange)))
            except Exception as e:
                pwdMustChange = '<never>'
                pass

            if user['UserAccountControl'] & samr.USER_DONT_EXPIRE_PASSWORD:
                dontExpire = 'True'
            else:
                dontExpire = 'False'

            if user['UserAccountControl'] & samr.USER_ACCOUNT_DISABLED:
                accountDisabled = 'True'
            else:
                accountDisabled = 'False'

            if self.__csvOutput is True:
                output.info(
                    '%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s' % (username, uid, user['FullName'], user['PrimaryGroupId'],
                                                          user['BadPasswordCount'], user['LogonCount'], pwdLastSet,
                                                          dontExpire, accountDisabled,
                                                          user['UserComment'].replace(',', '.'),
                                                          user['ScriptPath']))
            else:
                base = "%s (%d)" % (username, uid)
                output.info(f"{base}{'/FullName:':<50}{user['FullName']}")
                output.info(f"{base}{'/UserComment:':<50}{user['UserComment']}")
                output.info(f"{base}{'/PrimaryGroupId:':<50}{user['PrimaryGroupId']}")
                output.info(f"{base}{'/BadPasswordCount:':<50}{user['BadPasswordCount']}")
                output.info(f"{base}{'/LogonCount(start computer will reset value):':<50}{user['LogonCount']}")
                output.info(f"{base}{'/PasswordLastSet:':<50}{pwdLastSet}")
                output.info(f"{base}{'/PasswordCanChange:':<50}{pwCanChange}")
                output.info(f"{base}{'/UserLastLogon:':<50}{UserLastLogon}")
                output.info(f"{base}{'/ForcePasswordChange:':<50}{pwdMustChange}")
                output.info(f"{base}{'/PasswordDoesNotExpire:':<50}{dontExpire}")
                output.info(f"{base}{'/AccountIsDisabled:':<50}{accountDisabled}")
                output.info(f"{base}{'/ScriptPath:':<50}{user['ScriptPath']}\n")
                output.info(base + "/Domain Group Number: ")
                for name in ridname['Element']:
                    name.dump()
                output.info("\n")

        if entries:
            num = len(entries)
            if 1 == num:
                output.info('Received one entry.')
            else:
                output.info('Received %d entries.' % num)
        else:
            output.info('No entries received.')

    def __fetchList(self, rpctransport, username, groupname):
        dce = rpctransport.get_dce_rpc()

        entries = []

        dce.connect()
        dce.bind(samr.MSRPC_UUID_SAMR)

        try:
            resp = samr.hSamrConnect(dce)
            serverHandle = resp['ServerHandle']

            resp = samr.hSamrEnumerateDomainsInSamServer(dce, serverHandle)
            domains = resp['Buffer']['Buffer']

            output.info('Found domain(s):')
            for domain in domains:
                output.info(" . %s" % domain['Name'])

            output.info("Looking up users in domain %s" % domains[0]['Name'])

            resp = samr.hSamrLookupDomainInSamServer(dce, serverHandle, domains[0]['Name'])

            resp = samr.hSamrOpenDomain(dce, serverHandle=serverHandle, domainId=resp['DomainId'])
            domainHandle = resp['DomainHandle']

            status = STATUS_MORE_ENTRIES
            enumerationContext = 0
            while status == STATUS_MORE_ENTRIES:
                # search user in domain
                if username is not None:
                    userrid = []
                    userrid.append(username)
                    try:
                        resp = samr.hSamrLookupNamesInDomain(dce, domainHandle, userrid)
                    except Exception as e:
                        if str(e).find('STATUS_MORE_ENTRIES') >= 0:
                            pass
                        e.get_packet()

                    for __rid in resp['RelativeIds']['Element']:
                        r = samr.hSamrOpenUser(dce, domainHandle, samr.MAXIMUM_ALLOWED, __rid)
                        info = samr.hSamrQueryInformationUser2(dce, r['UserHandle'],
                                                               samr.USER_INFORMATION_CLASS.UserAllInformation)
                        sec = samr.hSamrQuerySecurityObject(dce, r['UserHandle'], dtypes.DACL_SECURITY_INFORMATION)
                        usergroup = samr.hSamrGetGroupsForUser(dce, r['UserHandle'])
                        rids = []
                        for rid in usergroup['Groups']['Groups']:
                            _rid = rid['RelativeId']
                            rids.append(_rid)
                        ridname = samr.hSamrLookupIdsInDomain(dce, domainHandle, rids)
                        intuid = int.from_bytes(__rid.getData(), 'little')
                        output.info(intuid)
                        entry = (username, intuid, info['Buffer']['All'], rids, ridname['Names'])
                        entries.append(entry)
                        samr.hSamrCloseHandle(dce, r['UserHandle'])
                # search group in domain
                elif groupname is not None:
                    grouprid = []
                    grouprid.append(groupname)
                    try:
                        resp = samr.hSamrLookupNamesInDomain(dce, domainHandle, grouprid)
                    except Exception as e:
                        if str(e).find('STATUS_MORE_ENTRIES') >= 0:
                            pass
                        e.get_packet()

                    for __rid in resp['RelativeIds']['Element']:
                        r = samr.hSamrOpenGroup(dce, domainHandle, samr.MAXIMUM_ALLOWED, __rid)
                        info = samr.hSamrGetMembersInGroup(dce, r['GroupHandle'])
                        rids = []
                        for rid in info['Members']['Members']:
                            rid = int.from_bytes(rid.getData(), 'little')
                            rids.append(rid)
                        ridname = samr.hSamrLookupIdsInDomain(dce, domainHandle, rids)
                        output.info("Users in  %s : " % groupname)
                        for name in ridname['Names']['Element']:
                            name.dump()
                            output.info('\n')
                # search all user in domain
                else:
                    try:
                        resp = samr.hSamrEnumerateUsersInDomain(dce, domainHandle,
                                                                enumerationContext=enumerationContext)

                    except DCERPCException as e:
                        if str(e).find('STATUS_MORE_ENTRIES') < 0:
                            raise
                        resp = e.get_packet()

                    for user in resp['Buffer']['Buffer']:
                        r = samr.hSamrOpenUser(dce, domainHandle, samr.MAXIMUM_ALLOWED, user['RelativeId'])
                        output.info("Found user: %s, uid = %d" % (user['Name'], user['RelativeId']))
                        info = samr.hSamrQueryInformationUser2(dce, r['UserHandle'],
                                                               samr.USER_INFORMATION_CLASS.UserAllInformation)

                        sec = samr.hSamrQuerySecurityObject(dce, r['UserHandle'], dtypes.DACL_SECURITY_INFORMATION)

                        usergroup = samr.hSamrGetGroupsForUser(dce, r['UserHandle'])
                        rids = []
                        for rid in usergroup['Groups']['Groups']:
                            _rid = rid['RelativeId']
                            rids.append(_rid)
                        ridname = samr.hSamrLookupIdsInDomain(dce, domainHandle, rids)
                        entry = (user['Name'], user['RelativeId'], info['Buffer']['All'], rids, ridname['Names'])
                        entries.append(entry)
                        samr.hSamrCloseHandle(dce, r['UserHandle'])
                        enumerationContext = resp['EnumerationContext']

                status = resp['ErrorCode']

        except ListUsersException as e:
            output.critical("Error listing users: %s" % e)

        dce.disconnect()

        return entries
