import argparse
from copy import copy

from impacket.crypto import encryptSecret
from impacket.dcerpc.v5 import transport, scmr
from impacket.dcerpc.v5.ndr import NULL

from plugins.AD import PluginAdExploitBase, parse_user_args
from utils import output
from utils.consts import AllPluginTypes


class PluginADImpacketService(PluginAdExploitBase):
    display = "service"
    alias = "imp_serv"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-d", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("-u", "--username", help="username", required=True, dest="username")
        parser.add_argument("-p", "--password", help="password", required=False, dest="password")

        subparsers = parser.add_subparsers(help='actions', dest='action')

        # A start command
        start_parser = subparsers.add_parser('start', help='starts the service')
        start_parser.add_argument('--name', action='store', required=True, help='service name')

        # A stop command
        stop_parser = subparsers.add_parser('stop', help='stops the service')
        stop_parser.add_argument('--name', action='store', required=True, help='service name')

        # A delete command
        delete_parser = subparsers.add_parser('delete', help='deletes the service')
        delete_parser.add_argument('--name', action='store', required=True, help='service name')

        # A status command
        status_parser = subparsers.add_parser('status', help='returns service status')
        status_parser.add_argument('--name', action='store', required=True, help='service name')

        # A config command
        config_parser = subparsers.add_parser('config', help='returns service configuration')
        config_parser.add_argument('--name', action='store', required=True, help='service name')

        # A list command
        list_parser = subparsers.add_parser('list', help='list available services')

        # A create command
        create_parser = subparsers.add_parser('create', help='create a service')
        create_parser.add_argument('--name', action='store', required=True, help='service name')
        create_parser.add_argument('--display', action='store', required=True, help='display name')
        create_parser.add_argument('--path', action='store', required=True, help='binary path')

        # A change command
        create_parser = subparsers.add_parser('change', help='change a service configuration')
        create_parser.add_argument('--name', action='store', required=True, help='service name')
        create_parser.add_argument('--display', action='store', required=False, help='display name')
        create_parser.add_argument('--path', action='store', required=False, help='binary path')
        create_parser.add_argument('--service_type', action='store', required=False, help='service type')
        create_parser.add_argument('--start_type', action='store', required=False, help='service start type')
        create_parser.add_argument('--start_name', action='store', required=False,
                                   help='string that specifies the name of '
                                        'the account under which the service should run')
        create_parser.add_argument('--password', action='store', required=False,
                                   help='string that contains the password of '
                                        'the account whose name was specified by the start_name parameter')

        group = parser.add_argument_group('authentication')

        group.add_argument('--hashes', action="store", metavar="LMHASH:NTHASH",
                           help='NTLM hashes, format is LMHASH:NTHASH')
        group.add_argument('--no-pass', action="store_true", help='don\'t ask for password (useful for -k)')
        group.add_argument('-k', action="store_true",
                           help='Use Kerberos authentication. Grabs credentials from ccache file '
                                '(KRB5CCNAME) based on target parameters. If valid credentials cannot be found, it will use the '
                                'ones specified in the command line')
        group.add_argument('--aesKey', action="store", metavar="hex key",
                           help='AES key to use for Kerberos Authentication '
                                '(128 or 256 bits)')

        group = parser.add_argument_group('connection')

        group.add_argument('--dc-ip', action='store', metavar="ip address",
                           help='IP Address of the domain controller. If '
                                'ommited it use the domain part (FQDN) specified in the target parameter')
        group.add_argument('--target-ip', action='store', metavar="ip address",
                           help='IP Address of the target machine. If '
                                'ommited it will use whatever was specified as target. This is useful when target is the NetBIOS '
                                'name and you cannot resolve it')
        group.add_argument('--port', choices=['139', '445'], nargs='?', default='445', metavar="destination port",
                           help='Destination port to connect to SMB Server')

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        _, domain, remoteName, _, _ = parse_user_args(args)
        username, password = args.username, args.password

        if domain is None:
            domain = ''

        if args.target_ip is None:
            args.target_ip = remoteName

        if args.aesKey is not None:
            args.k = True

        if password == '' and username != '' and args.hashes is None and args.no_pass is False and args.aesKey is None:
            from getpass import getpass
            password = getpass("Password:")

        services = SVCCTL(username, password, domain, args, int(args.port))
        try:
            services.run(remoteName, args.target_ip)
        except Exception as e:
            output.error(str(e))

        return result


class SVCCTL:

    def __init__(self, username, password, domain, options, port=445):
        self.__username = username
        self.__password = password
        self.__options = options
        self.__port = port
        self.__action = options.action.upper()
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__aesKey = options.aesKey
        self.__doKerberos = options.k
        self.__kdcHost = options.dc_ip

        if options.hashes is not None:
            self.__lmhash, self.__nthash = options.hashes.split(':')

    def run(self, remoteName, remoteHost):

        stringbinding = r'ncacn_np:%s[\pipe\svcctl]' % remoteName
        output.debug('StringBinding %s' % stringbinding)
        rpctransport = transport.DCERPCTransportFactory(stringbinding)
        rpctransport.set_dport(self.__port)
        rpctransport.setRemoteHost(remoteHost)
        if hasattr(rpctransport, 'set_credentials'):
            # This method exists only for selected protocol sequences.
            rpctransport.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash,
                                         self.__aesKey)

        rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)
        self.doStuff(rpctransport)

    def doStuff(self, rpctransport):
        dce = rpctransport.get_dce_rpc()
        # dce.set_credentials(self.__username, self.__password)
        dce.connect()
        # dce.set_max_fragment_size(1)
        # dce.set_auth_level(ntlm.NTLM_AUTH_PKT_PRIVACY)
        # dce.set_auth_level(ntlm.NTLM_AUTH_PKT_INTEGRITY)
        dce.bind(scmr.MSRPC_UUID_SCMR)
        # rpc = svcctl.DCERPCSvcCtl(dce)
        rpc = dce
        ans = scmr.hROpenSCManagerW(rpc)
        scManagerHandle = ans['lpScHandle']
        if self.__action != 'LIST' and self.__action != 'CREATE':
            ans = scmr.hROpenServiceW(rpc, scManagerHandle, self.__options.name + '\x00')
            serviceHandle = ans['lpServiceHandle']

        if self.__action == 'START':
            output.info("Starting service %s" % self.__options.name)
            scmr.hRStartServiceW(rpc, serviceHandle)
            scmr.hRCloseServiceHandle(rpc, serviceHandle)
        elif self.__action == 'STOP':
            output.info("Stopping service %s" % self.__options.name)
            scmr.hRControlService(rpc, serviceHandle, scmr.SERVICE_CONTROL_STOP)
            scmr.hRCloseServiceHandle(rpc, serviceHandle)
        elif self.__action == 'DELETE':
            output.info("Deleting service %s" % self.__options.name)
            scmr.hRDeleteService(rpc, serviceHandle)
            scmr.hRCloseServiceHandle(rpc, serviceHandle)
        elif self.__action == 'CONFIG':
            result_info = ""
            output.info("Querying service config for %s" % self.__options.name)
            resp = scmr.hRQueryServiceConfigW(rpc, serviceHandle)
            result_info += "TYPE              : %2d - " % resp['lpServiceConfig']['dwServiceType']
            if resp['lpServiceConfig']['dwServiceType'] & 0x1:
                result_info += "SERVICE_KERNEL_DRIVER "
            if resp['lpServiceConfig']['dwServiceType'] & 0x2:
                result_info += "SERVICE_FILE_SYSTEM_DRIVER "
            if resp['lpServiceConfig']['dwServiceType'] & 0x10:
                result_info += "SERVICE_WIN32_OWN_PROCESS "
            if resp['lpServiceConfig']['dwServiceType'] & 0x20:
                result_info += "SERVICE_WIN32_SHARE_PROCESS "
            if resp['lpServiceConfig']['dwServiceType'] & 0x100:
                result_info += "SERVICE_INTERACTIVE_PROCESS "
            result_info += "\n"
            result_info += "START_TYPE        : %2d - " % resp['lpServiceConfig']['dwStartType']
            if resp['lpServiceConfig']['dwStartType'] == 0x0:
                result_info += "BOOT START\n"
            elif resp['lpServiceConfig']['dwStartType'] == 0x1:
                result_info += "SYSTEM START\s"
            elif resp['lpServiceConfig']['dwStartType'] == 0x2:
                result_info += "AUTO START\n"
            elif resp['lpServiceConfig']['dwStartType'] == 0x3:
                result_info += "DEMAND START\n"
            elif resp['lpServiceConfig']['dwStartType'] == 0x4:
                result_info += "DISABLED\n"
            else:
                result_info += "UNKNOWN\n"

            result_info += "ERROR_CONTROL     : %2d - " % resp['lpServiceConfig']['dwErrorControl']
            if resp['lpServiceConfig']['dwErrorControl'] == 0x0:
                result_info += "IGNORE\n"
            elif resp['lpServiceConfig']['dwErrorControl'] == 0x1:
                result_info += "NORMAL\n"
            elif resp['lpServiceConfig']['dwErrorControl'] == 0x2:
                result_info += "SEVERE\n"
            elif resp['lpServiceConfig']['dwErrorControl'] == 0x3:
                result_info += "CRITICAL\n"
            else:
                result_info += "UNKNOWN\n"
            result_info += "BINARY_PATH_NAME  : %s\n" % resp['lpServiceConfig']['lpBinaryPathName'][:-1]
            result_info += "LOAD_ORDER_GROUP  : %s\n" % resp['lpServiceConfig']['lpLoadOrderGroup'][:-1]
            result_info += "TAG               : %d\n" % resp['lpServiceConfig']['dwTagId']
            result_info += "DISPLAY_NAME      : %s\n" % resp['lpServiceConfig']['lpDisplayName'][:-1]
            result_info += "DEPENDENCIES      : %s\n" % resp['lpServiceConfig']['lpDependencies'][:-1]
            result_info += "SERVICE_START_NAME: %s\n" % resp['lpServiceConfig']['lpServiceStartName'][:-1]
            output.info(result_info)
        elif self.__action == 'STATUS':
            result_info = ""
            output.info("Querying status for %s" % self.__options.name)
            resp = scmr.hRQueryServiceStatus(rpc, serviceHandle)
            result_info += "%30s - " % self.__options.name
            state = resp['lpServiceStatus']['dwCurrentState']
            if state == scmr.SERVICE_CONTINUE_PENDING:
                result_info += "CONTINUE PENDING\n"
            elif state == scmr.SERVICE_PAUSE_PENDING:
                result_info += "PAUSE PENDING\n"
            elif state == scmr.SERVICE_PAUSED:
                result_info += "PAUSED\n"
            elif state == scmr.SERVICE_RUNNING:
                result_info += "RUNNING\n"
            elif state == scmr.SERVICE_START_PENDING:
                result_info += "START PENDING\n"
            elif state == scmr.SERVICE_STOP_PENDING:
                result_info += "STOP PENDING\n"
            elif state == scmr.SERVICE_STOPPED:
                result_info += "STOPPED\n"
            else:
                result_info += "UNKNOWN\n"
            output.info(result_info)
        elif self.__action == 'LIST':
            result_info = "Listing services available on target\n"
            # resp = rpc.EnumServicesStatusW(scManagerHandle, svcctl.SERVICE_WIN32_SHARE_PROCESS )
            # resp = rpc.EnumServicesStatusW(scManagerHandle, svcctl.SERVICE_WIN32_OWN_PROCESS )
            # resp = rpc.EnumServicesStatusW(scManagerHandle, serviceType = svcctl.SERVICE_FILE_SYSTEM_DRIVER, serviceState = svcctl.SERVICE_STATE_ALL )
            resp = scmr.hREnumServicesStatusW(rpc, scManagerHandle)
            for i in range(len(resp)):
                result_info += "%30s - %70s - " % (resp[i]['lpServiceName'][:-1], resp[i]['lpDisplayName'][:-1])
                state = resp[i]['ServiceStatus']['dwCurrentState']
                if state == scmr.SERVICE_CONTINUE_PENDING:
                    result_info += "CONTINUE PENDING\n"
                elif state == scmr.SERVICE_PAUSE_PENDING:
                    result_info += "PAUSE PENDING\n"
                elif state == scmr.SERVICE_PAUSED:
                    result_info += "PAUSED\n"
                elif state == scmr.SERVICE_RUNNING:
                    result_info += "RUNNING\n"
                elif state == scmr.SERVICE_START_PENDING:
                    result_info += "START PENDING\n"
                elif state == scmr.SERVICE_STOP_PENDING:
                    result_info += "STOP PENDING\n"
                elif state == scmr.SERVICE_STOPPED:
                    result_info += "STOPPED\n"
                else:
                    result_info += "UNKNOWN\n"
            output.info(result_info)
            output.info("Total Services: %d" % len(resp))
        elif self.__action == 'CREATE':
            output.info("Creating service %s" % self.__options.name)
            scmr.hRCreateServiceW(rpc, scManagerHandle, self.__options.name + '\x00', self.__options.display + '\x00',
                                  lpBinaryPathName=self.__options.path + '\x00')
        elif self.__action == 'CHANGE':
            output.info("Changing service config for %s" % self.__options.name)
            if self.__options.start_type is not None:
                start_type = int(self.__options.start_type)
            else:
                start_type = scmr.SERVICE_NO_CHANGE
            if self.__options.service_type is not None:
                service_type = int(self.__options.service_type)
            else:
                service_type = scmr.SERVICE_NO_CHANGE

            if self.__options.display is not None:
                display = self.__options.display + '\x00'
            else:
                display = NULL

            if self.__options.path is not None:
                path = self.__options.path + '\x00'
            else:
                path = NULL

            if self.__options.start_name is not None:
                start_name = self.__options.start_name + '\x00'
            else:
                start_name = NULL

            if self.__options.password is not None:
                s = rpctransport.get_smb_connection()
                key = s.getSessionKey()
                try:
                    password = (self.__options.password + '\x00').encode('utf-16le')
                except UnicodeDecodeError:
                    import sys
                    password = (self.__options.password + '\x00').decode(sys.getfilesystemencoding()).encode('utf-16le')
                password = encryptSecret(key, password)
            else:
                password = NULL

            # resp = scmr.hRChangeServiceConfigW(rpc, serviceHandle,  display, path, service_type, start_type, start_name, password)
            scmr.hRChangeServiceConfigW(rpc, serviceHandle, service_type, start_type, scmr.SERVICE_ERROR_IGNORE, path,
                                        NULL, NULL, NULL, 0, start_name, password, 0, display)
            scmr.hRCloseServiceHandle(rpc, serviceHandle)
        else:
            output.error("Unknown action %s" % self.__action)

        scmr.hRCloseServiceHandle(rpc, scManagerHandle)

        dce.disconnect()

        return

    # Process command-line arguments.
