import argparse
import datetime
import os
import re
import socket
import sys
from copy import copy
from struct import unpack

import dns.resolver
import ldap3
from impacket.krb5 import constants
from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set
from impacket.krb5.ccache import CCache
from impacket.krb5.kerberosv5 import getKerberosTGS
from impacket.krb5.kerberosv5 import getKerberosTGT
from impacket.krb5.types import Principal, KerberosTime, Ticket
from impacket.spnego import SPNEGO_NegTokenInit, TypesMech
from impacket.structure import Structure
from ldap3 import LEVEL, MODIFY_DELETE, MODIFY_ADD, MODIFY_REPLACE
from ldap3 import Server, Connection, NTLM, ALL, SASL, KERBEROS
from ldap3.operation.bind import bind_operation
from pyasn1.codec.der import decoder, encoder
from pyasn1.type.univ import noValue

from plugins.AD import PluginAdExploitBase
from utils import output
from utils.consts import AllPluginTypes

RECORD_TYPE_MAPPING = {
    0: 'ZERO',
    1: 'A',
    2: 'NS',
    5: 'CNAME',
    6: 'SOA',
    33: 'SRV',
    65281: 'WINS'
}


class PluginADDNSTool(PluginAdExploitBase):
    display = "DNS查询修改"
    alias = "dns_tool"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-d", "--domain", help="dc fqdn (dc01.test.lab)", required=True, dest="domain")
        parser.add_argument("-u", "--username", help="username", required=True, dest="username")
        parser.add_argument("-p", "--password", help="password", required=False, dest="password")
        parser.add_argument("--dc-ip", help="domain ip address", required=False, dest="dc_ip")
        parser.add_argument("--forest", help="Search the ForestDnsZones instead of DomainDnsZones", required=False,
                            dest="forest")
        parser.add_argument("--legacy", help="Search the System partition (legacy DNS storage)", required=False,
                            dest="legacy")
        parser.add_argument("--zone", help="Zone to search in (if different than the current domain)", required=False,
                            dest="zone")
        parser.add_argument("--print-zones",
                            help="Only query all zones on the DNS server, no other modifications are made",
                            required=False, dest="print_zones")
        parser.add_argument("--tcp", help="use DNS over TCP", required=False, dest="tcp")

        agroup = parser.add_argument_group('authentication')

        agroup.add_argument("--hash", help='NTLM hashes, format is LMHASH:NTHASH', required=False,
                            metavar="LMHASH:NTHASH", dest="hash")
        agroup.add_argument("-k",
                            help="Use Kerberos authentication. Grabs credentials from ccache file "
                                 "(KRB5CCNAME) based on target parameters. If valid credentials cannot be "
                                 "found, it will use the "
                                 "ones specified in the command line", action=argparse.BooleanOptionalAction,
                            default=False,
                            required=False, dest="do_kerb")

        rgroup = parser.add_argument_group("Record options")
        rgroup.add_argument("-r", "--target", help="Record to target (FQDN)", required=True, dest="target")
        rgroup.add_argument("-a", "--action",
                            choices=['add', 'modify', 'query', 'remove', 'resurrect', 'ldapdelete'],
                            default='query',
                            help="Action to perform. Options: add (add a new record), modify ("
                                 "modify an existing record), query (show existing), remove (mark record "
                                 "for cleanup from DNS cache), delete (delete from LDAP). Default: query",
                            required=False, dest="action"
                            )
        rgroup.add_argument("-t", "--type", choices=['A'], default='A',
                            help="Record type to add (Currently only A records supported)", required=False, dest="type")
        rgroup.add_argument("--data", help="Record data (IP address)", required=False, dest="data")
        rgroup.add_argument("--allow-multiple", help="Allow multiple A records for the same name", required=False,
                            dest="allow_multiple")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        _domain_fqdn: str = args.domain
        _domain_name = ".".join(_domain_fqdn.split(".")[-2:])
        _dc_ip = args.dc_ip
        _username = args.username
        _password = args.password
        _forest = args.forest
        _legacy = args.legacy
        _zone = args.zone
        _print_zones = args.print_zones
        _tcp = args.tcp

        _hash = args.hash
        _do_kerb = args.do_kerb

        _target = args.target
        _action = args.action
        _type = args.type
        _data = args.data
        _allow_multiple = args.allow_multiple

        domain, user = _domain_name, _username
        if not _do_kerb:
            authentication = NTLM
            sasl_mech = None
        else:
            TGT = None
            TGS = None
            try:
                # Hashes
                lmhash, nthash = _hash.split(':')
                assert len(nthash) == 32
                password = ''
            except:
                # Password
                lmhash = ''
                nthash = ''
                password = _password
            if 'KRB5CCNAME' in os.environ and os.path.exists(os.environ['KRB5CCNAME']):
                _, _, TGT, TGS = CCache.parseFile(_domain_name, _username, 'ldap/%s' % _domain_fqdn)
            if _dc_ip is None:
                kdcHost = domain
            else:
                kdcHost = _dc_ip
            userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
            if not TGT and not TGS:
                tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash,
                                                                        None, kdcHost)
            elif TGT:
                # Has TGT
                tgt = TGT['KDC_REP']
                cipher = TGT['cipher']
                sessionKey = TGT['sessionKey']
            if not TGS:
                # Request TGS
                serverName = Principal('ldap/%s' % _domain_fqdn, type=constants.PrincipalNameType.NT_SRV_INST.value)
                TGS = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)
            else:
                # Convert to tuple expected
                TGS = (TGS['KDC_REP'], TGS['cipher'], TGS['sessionKey'], TGS['sessionKey'])
            authentication = SASL
            sasl_mech = KERBEROS

        # define the server and the connection
        s = Server(_domain_fqdn, get_info=ALL)
        output.info('Connecting to host...')
        c = Connection(s, user=f"{_domain_name}\\{_username}", password=_password, authentication=authentication,
                       sasl_mechanism=sasl_mech)
        output.info('Binding to host')
        # perform the Bind operation
        if authentication == NTLM:
            if not c.bind():
                output.error('Could not bind with specified credentials')
                output.info(c.result)
                sys.exit(1)
        else:
            ldap_kerberos(domain, kdcHost, None, userName, c, _domain_fqdn, TGS)
        output.success('Bind OK')
        domainroot = s.info.other['defaultNamingContext'][0]
        forestroot = s.info.other['rootDomainNamingContext'][0]
        if _forest:
            dnsroot = 'CN=MicrosoftDNS,DC=ForestDnsZones,%s' % forestroot
        else:
            if _legacy:
                dnsroot = 'CN=MicrosoftDNS,CN=System,%s' % domainroot
            else:
                dnsroot = 'CN=MicrosoftDNS,DC=DomainDnsZones,%s' % domainroot

        if _print_zones:
            zones = get_dns_zones(c, dnsroot)
            if len(zones) > 0:
                output.info('Found %d domain DNS zones:' % len(zones))
                for zone in zones:
                    output.info('    %s' % zone)
            forestdns = 'CN=MicrosoftDNS,DC=ForestDnsZones,%s' % s.info.other['rootDomainNamingContext'][0]
            zones = get_dns_zones(c, forestdns)
            if len(zones) > 0:
                output.info('Found %d forest DNS zones:' % len(zones))
                for zone in zones:
                    output.info('    %s' % zone)
            return result

        target = _target
        if _zone:
            zone = _zone
        else:
            # Default to current domain
            zone = ldap2domain(domainroot)

        if not target:
            output.error('You need to specify a target record')
            return result

        if target.lower().endswith(zone.lower()):
            target = target[:-(len(zone) + 1)]

        searchtarget = 'DC=%s,%s' % (zone, dnsroot)
        # print s.info.naming_contexts
        c.search(searchtarget, '(&(objectClass=dnsNode)(name=%s))' % ldap3.utils.conv.escape_filter_chars(target),
                 attributes=['dnsRecord', 'dNSTombstoned', 'name'])
        targetentry = None
        for entry in c.response:
            if entry['type'] != 'searchResEntry':
                continue
            targetentry = entry

        # Check if we have the required data
        if _action in ['add', 'modify', 'remove'] and not _data:
            output.info('This operation requires you to specify record data with --data')
            return result

        # Check if we need the target record to exists, and if yes if it does
        if _action in ['modify', 'remove', 'ldapdelete', 'resurrect', 'query'] and not targetentry:
            output.info('Target record not found!')
            return result

        if _action == 'query':
            output.info('Found record %s' % targetentry['attributes']['name'])
            for record in targetentry['raw_attributes']['dnsRecord']:
                dr = DNS_RECORD(record)
                # dr.dump()
                output.info(targetentry['dn'])
                print_record(dr, targetentry['attributes']['dNSTombstoned'])
                continue
        elif _action == 'add':
            # Only A records for now
            addtype = 1
            # Entry exists
            if targetentry:
                if not _allow_multiple:
                    for record in targetentry['raw_attributes']['dnsRecord']:
                        dr = DNS_RECORD(record)
                        if dr['Type'] == 1:
                            address = DNS_RPC_RECORD_A(dr['Data'])
                            output.info(
                                'Record already exists and points to %s. Use --action modify to overwrite or --allow-multiple to override this' % address.formatCanonical())
                            return result
                # If we are here, no A records exists yet
                record = new_record(addtype, get_next_serial(_domain_fqdn, zone, _tcp))
                record['Data'] = DNS_RPC_RECORD_A()
                record['Data'].fromCanonical(_data)
                output.info('Adding extra record')
                c.modify(targetentry['dn'], {'dnsRecord': [(MODIFY_ADD, record.getData())]})
                output.infoperation_result(c.result)
            else:
                node_data = {
                    # Schema is in the root domain (take if from schemaNamingContext to be sure)
                    'objectCategory': 'CN=Dns-Node,%s' % s.info.other['schemaNamingContext'][0],
                    'dNSTombstoned': False,
                    'name': target
                }
                record = new_record(addtype, get_next_serial(_domain_fqdn, zone, _tcp))
                record['Data'] = DNS_RPC_RECORD_A()
                record['Data'].fromCanonical(_data)
                record_dn = 'DC=%s,%s' % (target, searchtarget)
                node_data['dnsRecord'] = [record.getData()]
                output.info('Adding new record')
                c.add(record_dn, ['top', 'dnsNode'], node_data)
                output.infoperation_result(c.result)
        elif _action == 'modify':
            # Only A records for now
            addtype = 1
            # We already know the entry exists
            targetrecord = None
            records = []
            for record in targetentry['raw_attributes']['dnsRecord']:
                dr = DNS_RECORD(record)
                if dr['Type'] == 1:
                    targetrecord = dr
                else:
                    records.append(record)
            if not targetrecord:
                output.info('No A record exists yet. Use --action add to add it')
            targetrecord['Serial'] = get_next_serial(_domain_fqdn, zone, _tcp)
            targetrecord['Data'] = DNS_RPC_RECORD_A()
            targetrecord['Data'].fromCanonical(_data)
            records.append(targetrecord.getData())
            output.info('Modifying record')
            c.modify(targetentry['dn'], {'dnsRecord': [(MODIFY_REPLACE, records)]})
            output.infoperation_result(c.result)
        elif _action == 'remove':
            addtype = 0
            if len(targetentry['raw_attributes']['dnsRecord']) > 1:
                output.info('Target has multiple records, removing the one specified')
                targetrecord = None
                for record in targetentry['raw_attributes']['dnsRecord']:
                    dr = DNS_RECORD(record)
                    if dr['Type'] == 1:
                        tr = DNS_RPC_RECORD_A(dr['Data'])
                        if tr.formatCanonical() == _data:
                            targetrecord = record
                if not targetrecord:
                    output.info('Could not find a record with the specified data')
                    return result
                c.modify(targetentry['dn'], {'dnsRecord': [(MODIFY_DELETE, targetrecord)]})
                output.infoperation_result(c.result)
            else:
                output.info('Target has only one record, tombstoning it')
                diff = datetime.datetime.today() - datetime.datetime(1601, 1, 1)
                tstime = int(diff.total_seconds() * 10000)
                # Add a null record
                record = new_record(addtype, get_next_serial(_domain_fqdn, zone, _tcp))
                record['Data'] = DNS_RPC_RECORD_TS()
                record['Data']['entombedTime'] = tstime
                c.modify(targetentry['dn'], {'dnsRecord': [(MODIFY_REPLACE, [record.getData()])],
                                             'dNSTombstoned': [(MODIFY_REPLACE, True)]})
                output.infoperation_result(c.result)
        elif _action == 'ldapdelete':
            output.info('Deleting record over LDAP')
            c.delete(targetentry['dn'])
            output.infoperation_result(c.result)
        elif _action == 'resurrect':
            addtype = 0
            if len(targetentry['raw_attributes']['dnsRecord']) > 1:
                output.info('Target has multiple records, I dont  know how to handle this.')
                return result
            else:
                output.info('Target has only one record, resurrecting it')
                diff = datetime.datetime.today() - datetime.datetime(1601, 1, 1)
                tstime = int(diff.total_seconds() * 10000)
                # Add a null record
                record = new_record(addtype, get_next_serial(_domain_fqdn, zone, _tcp))
                record['Data'] = DNS_RPC_RECORD_TS()
                record['Data']['entombedTime'] = tstime
                c.modify(targetentry['dn'], {'dnsRecord': [(MODIFY_REPLACE, [record.getData()])],
                                             'dNSTombstoned': [(MODIFY_REPLACE, False)]})
                output.success('Record resurrected. You will need to (re)add the record with the IP address.')

        return result


class DNS_RECORD(Structure):
    """
    dnsRecord - used in LDAP
    [MS-DNSP] section 2.3.2.2
    """
    structure = (
        ('DataLength', '<H-Data'),
        ('Type', '<H'),
        ('Version', 'B=5'),
        ('Rank', 'B'),
        ('Flags', '<H=0'),
        ('Serial', '<L'),
        ('TtlSeconds', '>L'),
        ('Reserved', '<L=0'),
        ('TimeStamp', '<L=0'),
        ('Data', ':')
    )


# Note that depending on whether we use RPC or LDAP all the DNS_RPC_XXXX
# structures use DNS_RPC_NAME when communication is over RPC,
# but DNS_COUNT_NAME is the way they are stored in LDAP.
#
# Since LDAP is the primary goal of this script we use that, but for use
# over RPC the DNS_COUNT_NAME in the structures must be replaced with DNS_RPC_NAME,
# which is also consistent with how MS-DNSP describes it.

class DNS_RPC_NAME(Structure):
    """
    DNS_RPC_NAME
    Used for FQDNs in RPC communication.
    MUST be converted to DNS_COUNT_NAME for LDAP
    [MS-DNSP] section 2.2.2.2.1
    """
    structure = (
        ('cchNameLength', 'B-dnsName'),
        ('dnsName', ':')
    )


class DNS_COUNT_NAME(Structure):
    """
    DNS_COUNT_NAME
    Used for FQDNs in LDAP communication
    MUST be converted to DNS_RPC_NAME for RPC communication
    [MS-DNSP] section 2.2.2.2.2
    """
    structure = (
        ('Length', 'B-RawName'),
        ('LabelCount', 'B'),
        ('RawName', ':')
    )

    def toFqdn(self):
        ind = 0
        labels = []
        for i in range(self['LabelCount']):
            nextlen = unpack('B', self['RawName'][ind:ind + 1])[0]
            labels.append(self['RawName'][ind + 1:ind + 1 + nextlen].decode('utf-8'))
            ind += nextlen + 1
        # For the final dot
        labels.append('')
        return '.'.join(labels)


class DNS_RPC_NODE(Structure):
    """
    DNS_RPC_NODE
    [MS-DNSP] section 2.2.2.2.3
    """
    structure = (
        ('wLength', '>H'),
        ('wRecordCount', '>H'),
        ('dwFlags', '>L'),
        ('dwChildCount', '>L'),
        ('dnsNodeName', ':')
    )


class DNS_RPC_RECORD_A(Structure):
    """
    DNS_RPC_RECORD_A
    [MS-DNSP] section 2.2.2.2.4.1
    """
    structure = (
        ('address', ':'),
    )

    def formatCanonical(self):
        return socket.inet_ntoa(self['address'])

    def fromCanonical(self, canonical):
        self['address'] = socket.inet_aton(canonical)


class DNS_RPC_RECORD_NODE_NAME(Structure):
    """
    DNS_RPC_RECORD_NODE_NAME
    [MS-DNSP] section 2.2.2.2.4.2
    """
    structure = (
        ('nameNode', ':', DNS_COUNT_NAME),
    )


class DNS_RPC_RECORD_SOA(Structure):
    """
    DNS_RPC_RECORD_SOA
    [MS-DNSP] section 2.2.2.2.4.3
    """
    structure = (
        ('dwSerialNo', '>L'),
        ('dwRefresh', '>L'),
        ('dwRetry', '>L'),
        ('dwExpire', '>L'),
        ('dwMinimumTtl', '>L'),
        ('namePrimaryServer', ':', DNS_COUNT_NAME),
        ('zoneAdminEmail', ':', DNS_COUNT_NAME)
    )


class DNS_RPC_RECORD_NULL(Structure):
    """
    DNS_RPC_RECORD_NULL
    [MS-DNSP] section 2.2.2.2.4.4
    """
    structure = (
        ('bData', ':'),
    )


# Some missing structures here that I skipped

class DNS_RPC_RECORD_NAME_PREFERENCE(Structure):
    """
    DNS_RPC_RECORD_NAME_PREFERENCE
    [MS-DNSP] section 2.2.2.2.4.8
    """
    structure = (
        ('wPreference', '>H'),
        ('nameExchange', ':', DNS_COUNT_NAME)
    )


# Some missing structures here that I skipped

class DNS_RPC_RECORD_AAAA(Structure):
    """
    DNS_RPC_RECORD_AAAA
    [MS-DNSP] section 2.2.2.2.4.17
    [MS-DNSP] section 2.2.2.2.4.17
    """
    structure = (
        ('ipv6Address', '16s'),
    )


class DNS_RPC_RECORD_SRV(Structure):
    """
    DNS_RPC_RECORD_SRV
    [MS-DNSP] section 2.2.2.2.4.18
    """
    structure = (
        ('wPriority', '>H'),
        ('wWeight', '>H'),
        ('wPort', '>H'),
        ('nameTarget', ':', DNS_COUNT_NAME)
    )


class DNS_RPC_RECORD_TS(Structure):
    """
    DNS_RPC_RECORD_TS
    [MS-DNSP] section 2.2.2.2.4.23
    """
    structure = (
        ('entombedTime', '<Q'),
    )

    def toDatetime(self):
        microseconds = self['entombedTime'] / 10.
        return datetime.datetime(1601, 1, 1) + datetime.timedelta(microseconds=microseconds)


def get_dns_zones(connection, root):
    connection.search(root, '(objectClass=dnsZone)', search_scope=LEVEL, attributes=['dc'])
    zones = []
    for entry in connection.response:
        if entry['type'] != 'searchResEntry':
            continue
        zones.append(entry['attributes']['dc'])
    return zones


def get_next_serial(server, zone, tcp):
    # Create a resolver object
    dnsresolver = dns.resolver.Resolver()
    # Is our host an IP? In that case make sure the server IP is used
    # if not assume lookups are working already
    try:
        socket.inet_aton(server)
        dnsresolver.nameservers = [server]
    except socket.error:
        pass
    res = dnsresolver.resolve(zone, 'SOA', tcp=tcp)
    for answer in res:
        return answer.serial + 1


def ldap2domain(ldap):
    return re.sub(',DC=', '.', ldap[ldap.find('DC='):], flags=re.I)[3:]


def print_record(record, ts=False):
    result = ""
    try:
        rtype = RECORD_TYPE_MAPPING[record['Type']]
    except KeyError:
        rtype = 'Unsupported'
    if ts:
        result = result + "Record is tombStoned (inactive)\n"
    result = f"{result}Record entry:\n{'':^4}- Type: {record['Type']} ({rtype}) (Serial: {record['Serial']})\n"

    if record['Type'] == 0:
        tstime = DNS_RPC_RECORD_TS(record['Data'])
        result = f"{result}{'':^4}- Tombstoned at: {tstime.toDatetime()}\n"
    # A record
    if record['Type'] == 1:
        address = DNS_RPC_RECORD_A(record['Data'])
        result = f"{result}{'':^4}- Address: {address.formatCanonical()}\n"
    # NS record or CNAME record
    if record['Type'] == 2 or record['Type'] == 5:
        address = DNS_RPC_RECORD_NODE_NAME(record['Data'])
        # address.dump()
        result = f"{result}{'':^4}- Address: {address['nameNode'].toFqdn()}"
    # SRV record
    if record['Type'] == 33:
        record_data = DNS_RPC_RECORD_SRV(record['Data'])
        # record_data.dump()
        result = f"{result}{'':^4}- Priority: {record_data['wPriority']}\n"
        result = f"{result}{'':^4}- Weight: {record_data['wWeight']}\n"
        result = f"{result}{'':^4}- Port: {record_data['wPort']}\n"
        result = f"{result}{'':^4}- Name: {record_data['nameTarget'].toFqdn()}\n"
    # SOA record
    if record['Type'] == 6:
        record_data = DNS_RPC_RECORD_SOA(record['Data'])
        # record_data.dump()
        result = f"{result}{'':^4}- Serial: {record_data['dwSerialNo']}\n"
        result = f"{result}{'':^4}- Refresh: {record_data['dwRefresh']}\n"
        result = f"{result}{'':^4}- Retry: {record_data['dwRetry']}\n"
        result = f"{result}{'':^4}- Expire: {record_data['dwExpire']}\n"
        result = f"{result}{'':^4}- Minimum TTL: {record_data['dwMinimumTtl']}\n"
        result = f"{result}{'':^4}- Primary server: {record_data['namePrimaryServer'].toFqdn()}\n"
        result = f"{result}{'':^4}- Zone admin email: {record_data['zoneAdminEmail'].toFqdn()}\n"
    output.info(result)


def new_record(rtype, serial):
    nr = DNS_RECORD()
    nr['Type'] = rtype
    nr['Serial'] = serial
    nr['TtlSeconds'] = 180
    # From authoritive zone
    nr['Rank'] = 240
    return nr


def print_operation_result(result):
    if result['result'] == 0:
        output.info('LDAP operation completed successfully')
        return True
    else:
        output.info(
            'LDAP operation failed. Message returned from server: %s %s' % (result['description'], result['message']))
        return False


def ldap_kerberos(domain, kdc, tgt, username, ldapconnection, hostname, tgs=None):
    gssapi_data = build_apreq(domain, kdc, tgt, username, 'ldap', hostname, tgs)

    return ldap_kerberos_auth(ldapconnection, gssapi_data)


def build_apreq(domain, kdc, tgt, username, serviceclass, hostname, tgs=None):
    # Build a protocol agnostic AP-REQ using the TGT we have, wrapped in GSSAPI/SPNEGO
    username = Principal(username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
    servername = Principal('%s/%s' % (serviceclass, hostname), type=constants.PrincipalNameType.NT_SRV_INST.value)
    if tgs:
        # If the TGS is already supplied, use that instead of TGT
        tgs, cipher, _, sessionkey = tgs
    else:
        tgs, cipher, _, sessionkey = getKerberosTGS(servername, domain, kdc,
                                                    tgt['KDC_REP'], tgt['cipher'], tgt['sessionKey'])

    # Let's build a NegTokenInit with a Kerberos AP_REQ
    blob = SPNEGO_NegTokenInit()

    # Kerberos
    blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]

    # Let's extract the ticket from the TGS
    tgs = decoder.decode(tgs, asn1Spec=TGS_REP())[0]
    ticket = Ticket()
    ticket.from_asn1(tgs['ticket'])

    # Now let's build the AP_REQ
    apReq = AP_REQ()
    apReq['pvno'] = 5
    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)

    opts = []
    apReq['ap-options'] = constants.encodeFlags(opts)
    seq_set(apReq, 'ticket', ticket.to_asn1)

    authenticator = Authenticator()
    authenticator['authenticator-vno'] = 5
    authenticator['crealm'] = domain
    seq_set(authenticator, 'cname', username.components_to_asn1)
    now = datetime.datetime.utcnow()

    authenticator['cusec'] = now.microsecond
    authenticator['ctime'] = KerberosTime.to_asn1(now)

    encodedAuthenticator = encoder.encode(authenticator)

    # Key Usage 11
    # AP-REQ Authenticator (includes application authenticator
    # subkey), encrypted with the application session key
    # (Section 5.5.1)
    encryptedEncodedAuthenticator = cipher.encrypt(sessionkey, 11, encodedAuthenticator, None)

    apReq['authenticator'] = noValue
    apReq['authenticator']['etype'] = cipher.enctype
    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator

    blob['MechToken'] = encoder.encode(apReq)
    return blob.getData()

def ldap_kerberos_auth(ldapconnection, authdata_gssapi):
    # Hackery to authenticate with ldap3 using impacket Kerberos stack
    # I originally wrote this for BloodHound.py, but it works fine (tm) here too
    ldapconnection.open(read_server_info=False)
    request = bind_operation(ldapconnection.version, SASL, None, None, ldapconnection.sasl_mechanism, authdata_gssapi)
    response = ldapconnection.post_send_single_response(ldapconnection.send('bindRequest', request, None))[0]
    ldapconnection.result = response
    if response['result'] == 0:
        ldapconnection.bound = True
        ldapconnection.refresh_server_info()
    return response['result'] == 0